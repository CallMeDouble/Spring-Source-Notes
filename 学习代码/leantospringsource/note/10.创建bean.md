# 创建bean

- 当经历过resolveBeforeInstantiation方法后，程序有两个选择，如果创建了代理或者说重写了InstantiationAwareBeanPostProcessor的postProcessBeforeInstantiation方法并在方法postProcessBeforeInstantiation方法并在方法postProcessBeforeInstantiation中改变了bean，则直接返回就可以了，否则需要进行常规bean的创建。
- 而这常规bean的创建就是在doCreateBean中完成的。

```Java
	//AbstractAutowireCapableBeanFactory
	protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args)
			throws BeanCreationException {

		// Instantiate the bean.
		BeanWrapper instanceWrapper = null;
		if (mbd.isSingleton()) {
			instanceWrapper = this.factoryBeanInstanceCache.remove(beanName);
		}
		if (instanceWrapper == null) {
			//根据指定bean使用对应的策略创建新的实例，如：工厂方法、构造函数自动注入。简单初始化
			instanceWrapper = createBeanInstance(beanName, mbd, args);
		}
		final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null);
		Class<?> beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null);
		mbd.resolvedTargetType = beanType;

		// Allow post-processors to modify the merged bean definition.
		synchronized (mbd.postProcessingLock) {
			if (!mbd.postProcessed) {
				try {
					//应用MergedBeanDefinitionPostProcessor
					applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							"Post-processing of merged bean definition failed", ex);
				}
				mbd.postProcessed = true;
			}
		}

		// Eagerly cache singletons to be able to resolve circular references
		// even when triggered by lifecycle interfaces like BeanFactoryAware.
		//是否需要提前曝光：单例&允许循环依赖&当前bean正在创建中，检测循环依赖
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isDebugEnabled()) {
				logger.debug("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			//为了避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory加入工厂
			addSingletonFactory(beanName, new ObjectFactory<Object>() {
				@Override
				public Object getObject() throws BeansException {
					//对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor，
					//其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有则直接返回bean，不做任何处理
					return getEarlyBeanReference(beanName, mbd, bean);
				}
			});
		}

		// Initialize the bean instance.
		Object exposedObject = bean;
		try {
			//对bean进行填充，将各个属性值注入，其中，可能存在依赖于其他bean的属性，则会递归初始依赖bean
			populateBean(beanName, mbd, instanceWrapper);
			if (exposedObject != null) {
				//调用初始化方法，比如init-method
				exposedObject = initializeBean(beanName, exposedObject, mbd);
			}
		}
		catch (Throwable ex) {
			if (ex instanceof BeanCreationException && beanName.equals(((BeanCreationException) ex).getBeanName())) {
				throw (BeanCreationException) ex;
			}
			else {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, "Initialization of bean failed", ex);
			}
		}

		if (earlySingletonExposure) {
			Object earlySingletonReference = getSingleton(beanName, false);
			//earlySingletonReference只有在检测到有循环依赖的情况下才会不为空
			if (earlySingletonReference != null) {
				//如果exposedObject没有在初始化方法中被改变，也就是没有被增强
				if (exposedObject == bean) {
					exposedObject = earlySingletonReference;
				}
				else if (!this.allowRawInjectionDespiteWrapping && hasDependentBean(beanName)) {
					String[] dependentBeans = getDependentBeans(beanName);
					Set<String> actualDependentBeans = new LinkedHashSet<String>(dependentBeans.length);
					for (String dependentBean : dependentBeans) {
						//检测依赖
						if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) {
							actualDependentBeans.add(dependentBean);
						}
					}
					/**
					 * 因为bean创建后其所依赖的bean一定是已经创建的，
					 * actualDependBeans不为空则表示当前bean创建后其依赖的bean却没有没全部创建完，也就是说存在循环依赖
					 */
					if (!actualDependentBeans.isEmpty()) {
						throw new BeanCurrentlyInCreationException(beanName,
								"Bean with name '" + beanName + "' has been injected into other beans [" +
								StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +
								"] in its raw version as part of a circular reference, but has eventually been " +
								"wrapped. This means that said other beans do not use the final version of the " +
								"bean. This is often the result of over-eager type matching - consider using " +
								"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.");
					}
				}
			}
		}

		// Register bean as disposable.
		try {
			//根据scopse注册bean
			registerDisposableBeanIfNecessary(beanName, bean, mbd);
		}
		catch (BeanDefinitionValidationException ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, "Invalid destruction signature", ex);
		}

		return exposedObject;
	}
```

- 整个函数的概要思路：

1. 如果是单例则需要首先清除缓存。
2. 实例化bean，将BeanDefinition转换为BeanWrapper。

- - 转换是一个复杂的过程，但是我们可以尝试概括大致的功能，如下所示：
  - 1. 如果存在工厂方法则使用工厂方法进行初始化。
    2. 一个类有多个构造函数，每个构造函数都有不同的参数，所以需要根据参数锁定构造函数并进行初始化。
    3. 如果既不存在工厂方法也不存在带有参数的构造函数，则使用默认的构造函数进行bean的实例化。

3. MergedBeanDefinitionPostProcessor的应用。

- - bean合并后的处理，Autowired注解正是通过此方法实现诸如类型的预解析。

4. 依赖处理。

- - 在Spring中会有循环依赖的情况，例如，当A中含有B的属性，而B中又含有A的属性时就会构成一个循环依赖，此时如果A和B都是单例，那么在Spring中的处理方式就是当创建B的时候，涉及自动注入A的步骤时，并不是直接去再次创建A，而是通过放入缓存中的ObjectFactory来创建实例，这样就解决了循环依赖的问题。

5. 属性填充。

- - 将所有属性填充至bean的实例中。

6. 循环依赖检查。

- - 在Spring中解决循环依赖只对单例有效，而对于prototype的bean，Spring唯一要做的就是抛出异常。
  - 在这个步骤里会检测已经加载的bean是否已经出现依赖循环，并判断是否需要抛出异常。

7. 注册DisposableBean。

- - 如果配置了destroy-method，这里需要注册以便于在销毁时候调用。

8. 完成创建并返回。

- 上面的步骤非常的繁琐，每一步骤都使用了大量的代码来完成其功能。
- 最复杂和最难以理解的是循环依赖的处理，在真正进入doCreateBean前先了解一下循环依赖。

---

# 1.创建bean的实例

- 首先从ceateBeanInstance开始：

```Java
	//AbstractAutowireCapableBeanFactory
	protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) {
		// Make sure bean class is actually resolved at this point.
		//解析Class
		Class<?> beanClass = resolveBeanClass(mbd, beanName);

		if (beanClass != null && !Modifier.isPublic(beanClass.getModifiers()) && !mbd.isNonPublicAccessAllowed()) {
			throw new BeanCreationException(mbd.getResourceDescription(), beanName,
					"Bean class isn't public, and non-public access not allowed: " + beanClass.getName());
		}
		//如果工厂方法不为空则使用工厂方法初始化策略
		if (mbd.getFactoryMethodName() != null)  {
			return instantiateUsingFactoryMethod(beanName, mbd, args);
		}

		// Shortcut when re-creating the same bean...
		boolean resolved = false;
		boolean autowireNecessary = false;
		if (args == null) {
			synchronized (mbd.constructorArgumentLock) {
				//一个类有多个构造函数，每个构造函数都有不同的参数，所以调用前需要先根据参数锁定构造函数或对应的工厂方法
				if (mbd.resolvedConstructorOrFactoryMethod != null) {
					resolved = true;
					autowireNecessary = mbd.constructorArgumentsResolved;
				}
			}
		}
		//如果已经解析过则使用解析好的构造函数方法，不需要再次锁定
		if (resolved) {
			if (autowireNecessary) {
				//构造函数自动注入
				return autowireConstructor(beanName, mbd, null, null);
			}
			else {
				//使用默认构造函数构造
				return instantiateBean(beanName, mbd);
			}
		}

		// Need to determine the constructor...
		//需要根据参数解析构造函数
		Constructor<?>[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);
		if (ctors != null ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||
				mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  {
			//构造函数自动注入
			return autowireConstructor(beanName, mbd, ctors, args);
		}

		// No special handling: simply use no-arg constructor.
		//使用默认构造函数构造
		return instantiateBean(beanName, mbd);
	}
```

- 该方法实例化的逻辑：

1. 如果在RootBeanDefinition中存在factoryMethodName属性，或者说在配置文件中配置了factory-method，那么Spring会尝试使用`instantiateUsingFactoryMethod(beanName, mbd, args)`方法根据RootBeanDefinition中的配置生成bean的实例。
2. 解析构造函数并进行构造函数的实例化。

- - 因为一个bean对应的类中可能会有多个构造函数，而每个构造函数的参数不同，Spring在根据参数及类型去判断最终会使用哪个构造函数进行实例化。
  - 判断的过程是个比较消耗性能的步骤，所以采用缓存机制，如果已经解析过则不需要重复解析而是直接从RootBeanDefinition中的属性resolvedConstructorOrFactoryMethod缓存的值去取，否则需要再次解析，并将解析的结果添加至RootBeanDefinition中的属性resolvedConstructorOrFactoryMethod中。

### 1.autowireConstructor

- 对于实例化的创建Spring中分成两种情况，一种是通用的实例化，另一种是带有参数的实例化。
- 带有参数的实例化过程相当复杂，因为存在不确定性，所以在判断对于参数上做了大量工作。

```Java
	//AbstractAutowireCapableBeanFactory
	protected BeanWrapper autowireConstructor(
			String beanName, RootBeanDefinition mbd, Constructor<?>[] ctors, Object[] explicitArgs) {

		return new ConstructorResolver(this).autowireConstructor(beanName, mbd, ctors, explicitArgs);
	}

	//ConstructorResolver
	public BeanWrapper autowireConstructor(final String beanName, final RootBeanDefinition mbd,
			Constructor<?>[] chosenCtors, final Object[] explicitArgs) {

		BeanWrapperImpl bw = new BeanWrapperImpl();
		this.beanFactory.initBeanWrapper(bw);

		Constructor<?> constructorToUse = null;
		ArgumentsHolder argsHolderToUse = null;
		Object[] argsToUse = null;

		//explicitArgs通过getBean方法传入
 		//如果getBean方法调用的时候指定方法参数那么直接使用
		if (explicitArgs != null) {
			argsToUse = explicitArgs;
		}
		else {
			//如果在getBean方法时候没有指定则尝试从配置文件中解析
			Object[] argsToResolve = null;
			//尝试从缓存中获取
			synchronized (mbd.constructorArgumentLock) {
				constructorToUse = (Constructor<?>) mbd.resolvedConstructorOrFactoryMethod;
				if (constructorToUse != null && mbd.constructorArgumentsResolved) {
					// Found a cached constructor...
					//从缓存中取
					argsToUse = mbd.resolvedConstructorArguments;
					if (argsToUse == null) {
						//配置的构造函数参数
						argsToResolve = mbd.preparedConstructorArguments;
					}
				}
			}
			//如果缓存中存在
			if (argsToResolve != null) {
				//解析参数类型，如给定方法的构造函数A(int ,int)则通过此方法后就会把配置中的("1","1")转换为(1,1)
				//缓存中的值可能是原始值也可能是最终值
				argsToUse = resolvePreparedArguments(beanName, mbd, bw, constructorToUse, argsToResolve);
			}
		}

		//没有被缓存
		if (constructorToUse == null) {
			// Need to resolve the constructor.
			boolean autowiring = (chosenCtors != null ||
					mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR);
			ConstructorArgumentValues resolvedValues = null;

			int minNrOfArgs;
			if (explicitArgs != null) {
				minNrOfArgs = explicitArgs.length;
			}
			else {
				//提取配置文件中的配置的构造函数参数
				ConstructorArgumentValues cargs = mbd.getConstructorArgumentValues();
				//用于承载解析后的构造函数参数的值
				resolvedValues = new ConstructorArgumentValues();
				//能解析到的参数个数
				minNrOfArgs = resolveConstructorArguments(beanName, mbd, bw, cargs, resolvedValues);
			}

			// Take specified constructors, if any.
			Constructor<?>[] candidates = chosenCtors;
			if (candidates == null) {
				Class<?> beanClass = mbd.getBeanClass();
				try {
					candidates = (mbd.isNonPublicAccessAllowed() ?
							beanClass.getDeclaredConstructors() : beanClass.getConstructors());
				}
				catch (Throwable ex) {
					throw new BeanCreationException(mbd.getResourceDescription(), beanName,
							"Resolution of declared constructors on bean Class [" + beanClass.getName() +
							"] from ClassLoader [" + beanClass.getClassLoader() + "] failed", ex);
				}
			}
			//排序给定的构造函数，public构造函数优先参数数量降序、非public构造函数参数数量降序
			AutowireUtils.sortConstructors(candidates);
          
			int minTypeDiffWeight = Integer.MAX_VALUE;
			Set<Constructor<?>> ambiguousConstructors = null;
			LinkedList<UnsatisfiedDependencyException> causes = null;

			for (Constructor<?> candidate : candidates) {
				Class<?>[] paramTypes = candidate.getParameterTypes();

				if (constructorToUse != null && argsToUse.length > paramTypes.length) {
					// Already found greedy constructor that can be satisfied ->
					// do not look any further, there are only less greedy constructors left.
					//如果已经找到选用的构造函数或者需要的参数个数小于当前的构造函数个数则终止，因为已经按照参数个数降序排列
					break;
				}
				if (paramTypes.length < minNrOfArgs) {
					//参数不相等
					continue;
				}

				ArgumentsHolder argsHolder;
				if (resolvedValues != null) {
					//有参数则根据值构造对应参数类型的参数
					try {
						//注释上获取参数名称，没有注释则为null
						String[] paramNames = ConstructorPropertiesChecker.evaluate(candidate, paramTypes.length);
						if (paramNames == null) {
							//获取参数名称探索器
							ParameterNameDiscoverer pnd = this.beanFactory.getParameterNameDiscoverer();
							if (pnd != null) {
								//获取指定构造函数的参数名称
								paramNames = pnd.getParameterNames(candidate);
							}
						}
						//根据名称和数据类型创建参数持有者
						argsHolder = createArgumentArray(beanName, mbd, resolvedValues, bw, paramTypes, paramNames,
								getUserDeclaredConstructor(candidate), autowiring);
					}
					catch (UnsatisfiedDependencyException ex) {
						if (this.beanFactory.logger.isTraceEnabled()) {
							this.beanFactory.logger.trace(
									"Ignoring constructor [" + candidate + "] of bean '" + beanName + "': " + ex);
						}
						// Swallow and try next constructor.
						if (causes == null) {
							causes = new LinkedList<UnsatisfiedDependencyException>();
						}
						causes.add(ex);
						continue;
					}
				}
				else {
					// Explicit arguments given -> arguments length must match exactly.
					if (paramTypes.length != explicitArgs.length) {
						continue;
					}
					//构造函数没有参数的情况
					argsHolder = new ArgumentsHolder(explicitArgs);
				}

				//探测是否有不确定性的构造函数存在，例如不同构造函数的参数为父子关系
				int typeDiffWeight = (mbd.isLenientConstructorResolution() ?
						argsHolder.getTypeDifferenceWeight(paramTypes) : argsHolder.getAssignabilityWeight(paramTypes));
				// Choose this constructor if it represents the closest match.
				//如果它代表着当前最接近匹配则选择作为构造函数
				if (typeDiffWeight < minTypeDiffWeight) {
					constructorToUse = candidate;
					argsHolderToUse = argsHolder;
					argsToUse = argsHolder.arguments;
					minTypeDiffWeight = typeDiffWeight;
					ambiguousConstructors = null;
				}
				else if (constructorToUse != null && typeDiffWeight == minTypeDiffWeight) {
					if (ambiguousConstructors == null) {
						ambiguousConstructors = new LinkedHashSet<Constructor<?>>();
						ambiguousConstructors.add(constructorToUse);
					}
					ambiguousConstructors.add(candidate);
				}
			}

			if (constructorToUse == null) {
				if (causes != null) {
					UnsatisfiedDependencyException ex = causes.removeLast();
					for (Exception cause : causes) {
						this.beanFactory.onSuppressedException(cause);
					}
					throw ex;
				}
				throw new BeanCreationException(mbd.getResourceDescription(), beanName,
						"Could not resolve matching constructor " +
						"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities)");
			}
			else if (ambiguousConstructors != null && !mbd.isLenientConstructorResolution()) {
				throw new BeanCreationException(mbd.getResourceDescription(), beanName,
						"Ambiguous constructor matches found in bean '" + beanName + "' " +
						"(hint: specify index/type/name arguments for simple parameters to avoid type ambiguities): " +
						ambiguousConstructors);
			}

			if (explicitArgs == null) {
				//将解析的构造函数加入缓存
				argsHolderToUse.storeCache(mbd, constructorToUse);
			}
		}

		try {
			Object beanInstance;

			if (System.getSecurityManager() != null) {
				final Constructor<?> ctorToUse = constructorToUse;
				final Object[] argumentsToUse = argsToUse;
				beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {
					@Override
					public Object run() {
						return beanFactory.getInstantiationStrategy().instantiate(
								mbd, beanName, beanFactory, ctorToUse, argumentsToUse);
					}
				}, beanFactory.getAccessControlContext());
			}
			else {
				beanInstance = this.beanFactory.getInstantiationStrategy().instantiate(
						mbd, beanName, this.beanFactory, constructorToUse, argsToUse);
			}

			//将构建的实例加入BeanWrapper中
			bw.setBeanInstance(beanInstance);
			return bw;
		}
		catch (Throwable ex) {
			throw new BeanCreationException(mbd.getResourceDescription(), beanName,
					"Bean instantiation via constructor failed", ex);
		}
	}
```

- 总结整个函数，其实现的功能考虑了以下几个方面。

- 1. 构造函数参数的确定。

  - 根据explicitArgs参数判断。

    - 如果传入的参数explicitArgs不为空，那便可以直接确定参数，因为explicitArgs参数是在调用Bean的时候用户指定的，在BeanFactory类中存在这样的方法：

    ```Java
    Object getBean(String name, Object... args) throws BeansException;
    ```

    - 在获取bean的时候，用户不但可以指定bean的名称还可以指定bean所对应类的构造函数或者工厂方法的方法参数，主要用于静态工厂方法的调用，而这里是需要给定完全匹配的参数的。所以便可以判断，如果传入参数explicitArgs不为空，则可以确定构造函数参数就是它。

  - 缓存中获取

    - 除此之外，确定参数的办法如果之前已经分析过，也就是构造函数已经纪录在缓存中，那么便可以直接拿来使用。
    - 在缓存中缓存的可能是参数的最终类型也可能是参数的初始类型，例如：构造函数参数要求的是int类型，但是原始的参数值可能是String类型的“1”，那么即时在缓存中得到了参数，也需要经过类型转换器的过滤以确保参数类型与对应的构造函数参数类型完全对应。

  - 配置文件获取

    - 如果不能根据传入的参数explicitArgs确定构造函数的参数也无法在缓存中得到相关信息，那么就开启新一轮的分析了。
    - 分析从获取配置文件中配置的构造函数信息开始，经过之前的分析，我们知道Spring中配置文件中的信息经过转换都会通过BeanDefinition实例承载，也就是mbd中包含，那么可以通过调用`mbd.getConstructorArgumentValues()`获取配置的构造函数信息。
    - 有了配置中的信息便可以获取对应的参数信息了，获取参数值的信息包括直接指定值，如：直接指定构造函数中某个值为原始类型String类型，或者是一个对其他bean的引用，而这一处理委托给resolveConstructorArguments方法，并返回能解析到的参数的个数。

  2. 构造器的确定。
     - 经过了第一步后已经确定了构造函数的参数，接下来的任务就是根据构造函数参数在所有构造函数中锁定对应的构造函数。
     - 而匹配的方法就是根据参数个数匹配，所以在匹配之前需要先对构造函数按照public构造函数优先参数数量降序、非public构造函数参数数量降序。
     - 这样可以在遍历的情况下迅速判断排在后面的构造函数参数个数是否符合条件。
     - 由于在配置文件中并不是唯一限制使用参数位置索引的方式去创建，同样还支持指定参数名称进行设定参数值的情况，如`<constructor-arg name="aa">`，那么这种情况就需要首先确定构造函数中的参数名称。
     - 获取参数名称可以有两种方式，一种是通过注解的方式直接获取，另一种就是通过使用Spring中提供的工具类ParameterNameDiscoverer来获取。
     - 构造函数、参数名称、参数类型、参数值都确定后就可锁定构造函数以及转换对应的参数类型了。
  3. 根据确定的构造函数转化对应的参数类型。
     - 主要是使用Spring中提供的类型转换器或者用户提供的自定义类型转换器进行转换。
  4. 构造函数不确定性的验证。
     - 有时即使构造函数、参数名称、参数类型、参数值都确定后也不一定会直接锁定构造函数，不同构造函数的参数为父子关系，所以Spring在最后又做了一次验证。
  5. 根据实例化策略以及得到的构造函数及构造函数参数实例化Bean。

### 2.instantiateBean

```Java
	//AbstractAutowireCapableBeanFactory
	protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) {
		try {
			Object beanInstance;
			final BeanFactory parent = this;
			if (System.getSecurityManager() != null) {
				beanInstance = AccessController.doPrivileged(new PrivilegedAction<Object>() {
					@Override
					public Object run() {
						return getInstantiationStrategy().instantiate(mbd, beanName, parent);
					}
				}, getAccessControlContext());
			}
			else {
				beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);
			}
			BeanWrapper bw = new BeanWrapperImpl(beanInstance);
			initBeanWrapper(bw);
			return bw;
		}
		catch (Throwable ex) {
			throw new BeanCreationException(
					mbd.getResourceDescription(), beanName, "Instantiation of bean failed", ex);
		}
	}
```

- 此方法并没有什么实质性的逻辑，带有参数的实例化构造中，Spring把精力都放在了构造函数以及参数的匹配上。
- 所以没有参数的话那将是非常简单的一件事，直接调用实例化策略进行实例化就可以了。

### 3.实例化策略

- Spring没有使用最简单的反射方法直接反射来构造实例对象。

```Java
	//SimpleInstantiationStrategy
	@Override
	public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) {
		// Don't override the class with CGLIB if no overrides.
		//如果有需要覆盖或者动态替换的方法则当然需要使用cglib进行动态代理，因为可以在创建代理的同时将动态方法织入类中，
		//但是如果没有需要动态改变的方法，为了方便直接反射就可以了
		if (bd.getMethodOverrides().isEmpty()) {
			Constructor<?> constructorToUse;
			synchronized (bd.constructorArgumentLock) {
				constructorToUse = (Constructor<?>) bd.resolvedConstructorOrFactoryMethod;
				if (constructorToUse == null) {
					final Class<?> clazz = bd.getBeanClass();
					if (clazz.isInterface()) {
						throw new BeanInstantiationException(clazz, "Specified class is an interface");
					}
					try {
						if (System.getSecurityManager() != null) {
							constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction<Constructor<?>>() {
								@Override
								public Constructor<?> run() throws Exception {
									return clazz.getDeclaredConstructor((Class[]) null);
								}
							});
						}
						else {
							constructorToUse =	clazz.getDeclaredConstructor((Class[]) null);
						}
						bd.resolvedConstructorOrFactoryMethod = constructorToUse;
					}
					catch (Throwable ex) {
						throw new BeanInstantiationException(clazz, "No default constructor found", ex);
					}
				}
			}
			return BeanUtils.instantiateClass(constructorToUse);
		}
		else {
			// Must generate CGLIB subclass.
			return instantiateWithMethodInjection(bd, beanName, owner);
		}
	}

		//CglibSubclassingInstantiationStrategy#CglibSubclassCreator
		public Object instantiate(Constructor<?> ctor, Object... args) {
			Class<?> subclass = createEnhancedSubclass(this.beanDefinition);
			Object instance;
			if (ctor == null) {
				instance = BeanUtils.instantiateClass(subclass);
			}
			else {
				try {
					Constructor<?> enhancedSubclassConstructor = subclass.getConstructor(ctor.getParameterTypes());
					instance = enhancedSubclassConstructor.newInstance(args);
				}
				catch (Exception ex) {
					throw new BeanInstantiationException(this.beanDefinition.getBeanClass(),
							"Failed to invoke constructor for CGLIB enhanced subclass [" + subclass.getName() + "]", ex);
				}
			}
			// SPR-10785: set callbacks directly on the instance instead of in the
			// enhanced class (via the Enhancer) in order to avoid memory leaks.
			Factory factory = (Factory) instance;
			factory.setCallbacks(new Callback[] {NoOp.INSTANCE,
					new LookupOverrideMethodInterceptor(this.beanDefinition, this.owner),
					new ReplaceOverrideMethodInterceptor(this.beanDefinition, this.owner)});
			return instance;
		}
```

- 程序中，首先判断如果`beanDefinition.getMethodOverrides()`为空也就是用户没有使用replace或者lookup的配置方法，那么就直接使用反射的方式。
- 但是如果使用了这两个特性，就使用动态代理的方式将包含两个特性所对应的逻辑的拦截增强器设置进去。保证在调用方法的时候会被相应的拦截器增强，返回值为包含拦截器的代理实例。

# 记录创建bean的ObjectFactory

- 在doCreateBean函数中有这样一段代码：

```Java
		boolean earlySingletonExposure = (mbd.isSingleton() && this.allowCircularReferences &&
				isSingletonCurrentlyInCreation(beanName));
		if (earlySingletonExposure) {
			if (logger.isDebugEnabled()) {
				logger.debug("Eagerly caching bean '" + beanName +
						"' to allow for resolving potential circular references");
			}
			//为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory加入工厂
			addSingletonFactory(beanName, new ObjectFactory<Object>() {
				@Override
				public Object getObject() throws BeansException {
					//对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor，
					//其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有则直接返回bean，不做任何处理
					return getEarlyBeanReference(beanName, mbd, bean);
				}
			});
		}
```

- 这段代码不是很复杂，但是很多人不是太理解这段代码的作用。

- 而且这段代码仅从此函数中去理解也很难弄懂其中的含义，我们需要从全局的角度去思考Spring的依赖解决办法。

  - earlySingletonExposure：从字面的意思理解就是提早曝光的单例。

  - `mbd.isSingleton()`：此RootBeanDefinition代表的是否单例。

  - this.allowCircularReferences：在AbstractRefreshableApplicationContext中提供了设置函数，可以通过硬编码的方式进行设置或者可以通过自定义命名空间进行配置。

    - 其中硬编码的方式代码如下：

    ```Java
    ClassPathXmlApplicationContext bf = new ClassPathXmlApplicationContext("aspectTest.xml");
    bf.setAllowBeanDefinitionOverriding(false);
    ```

  - `isSingletonCurrentlyInCreation(beanName)`：该bean是否在创建中。

    - 在Spring中，会有个专门的属性默认为DefaultSingletonBeanRegistry的singletonsCurrentlyInCreation来记录bean的加载状态。
    - 在bean开始创建前会将beanName记录在属性中，在bean创建结束后会将beanName从属性中移除。
    - 不同的scope的记录位置并不一样，在singleton下记录属性的函数是在DefaultSingletonBeanRegistry类的`public Object getSingleton(String beanName, ObjectFactory singletonFactory)`函数的`beforeSingletonCreation(beanName)`和`afterSingletonCreation(beanName)`中，在这两段函数中分别`this.singletonsCurrentlyInCreation.add(beanName)`和`this.singletonsCurrentlyInCreation.remove(beanName)`来进行状态的记录与移除。

- 变量earlySingletonExposure是否是单例、是否允许循环依赖、是否对应的bean正在创建的条件的综合。

- 当这3个条件都满足时会执行addSingletonFactory操作。

### 加入SingletonFactory的作用与调用

- 以最简单AB循环依赖为例，类A中含有属性类B，而类B中又含有属性类A，初始化beanA的过程：
- ![](img/11.png?raw=true)
- 该图展示了创建beanA的流程，从图中我们看到，在创建A我的时候首先会记录类A所对应的beanName，并将beanA的创建工厂加入缓存中。
- 而在对A的属性填充也就是调用populate方法的时候又会在一次的对B进行递归创建。
- 同样的，因为B中同样存在A属性，因此在实例化B的populate方法中又会再次地初始化B，就是图形的最后，调用getBean(A)。
- 关键是在这里，在这个函数中并不是直接去实例化A，而是先去检测缓存中是否有已经创建好的对应的bean，或者是否已经创建好的ObjectFactory，而此时对于A的ObjectFactory早已经创建好，所以便不会再去向后执行，而是直接调用ObjectFactory去创建A，这里最关键的是ObjectFactory的实现。


```Java
			//AbstractAutowireCapableBeanFactory#doCreateBean
			addSingletonFactory(beanName, new ObjectFactory<Object>() {
				@Override
				public Object getObject() throws BeansException {
					return getEarlyBeanReference(beanName, mbd, bean);
				}
			});
```

- 其中getEarlyBeanReference的代码如下：

```Java
	//AbstractAutowireCapableBeanFactory
	protected Object getEarlyBeanReference(String beanName, RootBeanDefinition mbd, Object bean) {
		Object exposedObject = bean;
		if (bean != null && !mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof SmartInstantiationAwareBeanPostProcessor) {
					SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;
					exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);
					if (exposedObject == null) {
						return null;
					}
				}
			}
		}
		return exposedObject;
	}
```

- 在getEarlyBeanReference函数中并没有太多逻辑处理除了后处理器的调用。
- 根据以上分析，Spring处理循环依赖的解决办法是：
  - 在B中创建依赖A时通过ObjectFactory提供的实例化方法来中断A中的属性填充，使B中持有的A仅仅是刚刚初始化并没有填充任何属性的A，而这正初始化A的步骤还是在最开始创建A的时候进行的。
  - 但是因为A与B中的A所表示的属性地址是一样的，所以在A中创建好的属性填充自然可以通过B中的A获取，这样就解决了循环依赖的问题。

### 属性注入

- populateBean这个函数的主要功能就是属性填充：

```Java
	//AbstractAutowireCapableBeanFactory
	protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) {
		PropertyValues pvs = mbd.getPropertyValues();

		if (bw == null) {
			if (!pvs.isEmpty()) {
				throw new BeanCreationException(
						mbd.getResourceDescription(), beanName, "Cannot apply property values to null instance");
			}
			else {
				//没有可填充的属性
				// Skip property population phase for null instance.
				return;
			}
		}

		// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the
		// state of the bean before properties are set. This can be used, for example,
		// to support styles of field injection.
		//给InstantiationAwareBeanPostProcessors最后一次机会在属性设置前来改变bean
		//如：可以用来支持属性注入的类型
		boolean continueWithPropertyPopulation = true;

		if (!mbd.isSynthetic() && hasInstantiationAwareBeanPostProcessors()) {
			for (BeanPostProcessor bp : getBeanPostProcessors()) {
				if (bp instanceof InstantiationAwareBeanPostProcessor) {
					InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
					//返回值为是否继续填充bean
					if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) {
						continueWithPropertyPopulation = false;
						break;
					}
				}
			}
		}
		//如果后处理器发出停止填充命令则终止后续的执行
		if (!continueWithPropertyPopulation) {
			return;
		}

		if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||
				mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
			MutablePropertyValues newPvs = new MutablePropertyValues(pvs);

			// Add property values based on autowire by name if applicable.
			//根据名称自动注入
			if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) {
				autowireByName(beanName, mbd, bw, newPvs);
			}

			// Add property values based on autowire by type if applicable.
			//根据类型自动注入
			if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) {
				autowireByType(beanName, mbd, bw, newPvs);
			}

			pvs = newPvs;
		}

		//后处理器已经初始化
		boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();
		//需要依赖检查
		boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);

		if (hasInstAwareBpps || needsDepCheck) {
			PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);
			if (hasInstAwareBpps) {
				for (BeanPostProcessor bp : getBeanPostProcessors()) {
					if (bp instanceof InstantiationAwareBeanPostProcessor) {
						InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;
						//对所有需要依赖检查的属性进行后处理
						pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);
						if (pvs == null) {
							return;
						}
					}
				}
			}
			if (needsDepCheck) {
				//依赖检查，对应depends-on属性，3.0已经弃用此属性
				checkDependencies(beanName, mbd, filteredPds, pvs);
			}
		}

		//将属性应用到bean中
		applyPropertyValues(beanName, mbd, bw, pvs);
	}
```

- 在populateBean函数中提供了这样的处理流程：

  1. InstantiationAwareBeanPostProcessor处理器的postProcessAfterInstantiation函数的应用，此函数可以控制程序是否继续进行属性填充。
  2. 根据注入类型(byName/byType)，提取依赖的bean，并统一存入PropertyValues中。
  3. 应用InstantiationAwareBeanPostProcessor处理器的postProcessPropertyValues方法，对属性获取完毕填充前对属性的再次处理，典型应用是RequiredAnnotationBeanPostProcessor类中对属性的验证。
  4. 将所有PropertyValues中的属性填充至BeanWrapper中。

  - 在上面的步骤中，依赖注入（autowireByName/autowireByType）以及属性填充是比较重要的。

1. autowireByName

   - 上文提到根据注入类型（byName/byType），提取依赖的bean，并统一存入PropertyValues中，那么我们首先了解下byName功能是如何实现的。

   ```Java
   	//AbstractAutowireCapableBeanFactory
   	protected void autowireByName(
   			String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {

   		//寻找bw中需要依赖注入的属性
   		String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
   		for (String propertyName : propertyNames) {
   			if (containsBean(propertyName)) {
   				//递归初始化相关的bean
   				Object bean = getBean(propertyName);
   				pvs.add(propertyName, bean);
   				//注册依赖
   				registerDependentBean(propertyName, beanName);
   				if (logger.isDebugEnabled()) {
   					logger.debug("Added autowiring by name from bean name '" + beanName +
   							"' via property '" + propertyName + "' to bean named '" + propertyName + "'");
   				}
   			}
   			else {
   				if (logger.isTraceEnabled()) {
   					logger.trace("Not autowiring property '" + propertyName + "' of bean '" + beanName +
   							"' by name: no matching bean found");
   				}
   			}
   		}
   	}
   ```

   - 这个函数的功能是在传入的参数pvs中找出已经已经加载的bean，并递归实例化，进而加入到pvs中。

2. autowireByType

   - autowireByType与autowireByName使用的复杂程度都很相似，但是其实现功能的复杂度却完全不一样。

   ```Java
   	//AbstractAutowireCapableBeanFactory
   	protected void autowireByType(
   			String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs) {

   		TypeConverter converter = getCustomTypeConverter();
   		if (converter == null) {
   			converter = bw;
   		}

   		Set<String> autowiredBeanNames = new LinkedHashSet<String>(4);
   		//寻找bw中需要依赖注入的属性
   		String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);
   		for (String propertyName : propertyNames) {
   			try {
   				PropertyDescriptor pd = bw.getPropertyDescriptor(propertyName);
   				// Don't try autowiring by type for type Object: never makes sense,
   				// even if it technically is a unsatisfied, non-simple property.
   				if (Object.class != pd.getPropertyType()) {
   					//探测指定属性的set方法
   					MethodParameter methodParam = BeanUtils.getWriteMethodParameter(pd);
   					// Do not allow eager init for type matching in case of a prioritized post-processor.
   					boolean eager = !PriorityOrdered.class.isAssignableFrom(bw.getWrappedClass());
   					DependencyDescriptor desc = new AutowireByTypeDependencyDescriptor(methodParam, eager);
   					//解析指定beanName的属性所匹配的值，并把解析到的属性名称存储在autowiredBeanNames中，当属性存在多个封装bean时如：
   					//@Autowired private List<A> aList;将会找到所有匹配A类型的bean并将其注入
   					Object autowiredArgument = resolveDependency(desc, beanName, autowiredBeanNames, converter);
   					if (autowiredArgument != null) {
   						pvs.add(propertyName, autowiredArgument);
   					}
   					for (String autowiredBeanName : autowiredBeanNames) {
   						//注册依赖
   						registerDependentBean(autowiredBeanName, beanName);
   						if (logger.isDebugEnabled()) {
   							logger.debug("Autowiring by type from bean name '" + beanName + "' via property '" +
   									propertyName + "' to bean named '" + autowiredBeanName + "'");
   						}
   					}
   					autowiredBeanNames.clear();
   				}
   			}
   			catch (BeansException ex) {
   				throw new UnsatisfiedDependencyException(mbd.getResourceDescription(), beanName, propertyName, ex);
   			}
   		}
   	}
   ```

   - 实现根据名称自动匹配的第一步就是寻找bw中需要依赖注入的属性，同样对于根据类型自动匹配的实现来讲第一步也是寻找bw中需要依赖注入的属性，然后遍历这些属性并寻找类型匹配的bean，其中最复杂的就是寻找类型匹配的bean。
   - 同时，Spring中提供了对集合的类型注入的支持，如使用注解的方式：

   ```Java
   @Autowired
   private List<Test> tests;
   ```

   - Spring将会把所有与Test匹配的类型找出来并注入到tests属性中。
   - 所以在autowireByType函数中，新建了局部遍历autowiredBeanNames，用于存储所有依赖的bean，如果只是对非集合类的属性注入来说，此属性并无用处。
   - 对寻找类型匹配的逻辑实现封装在了resolveDependency函数中。

   ```Java
   	//DefaultListableBeanFactory
   	@Override
   	public Object resolveDependency(DependencyDescriptor descriptor, String requestingBeanName,
   			Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException {

   		descriptor.initParameterNameDiscovery(getParameterNameDiscoverer());
   		if (javaUtilOptionalClass == descriptor.getDependencyType()) {
   			return new OptionalDependencyFactory().createOptionalDependency(descriptor, requestingBeanName);
   		}
   		else if (ObjectFactory.class == descriptor.getDependencyType() ||
   				ObjectProvider.class == descriptor.getDependencyType()) {
   			//ObjectFactory和ObjectProvider类注入的特殊处理
   			return new DependencyObjectProvider(descriptor, requestingBeanName);
   		}
   		else if (javaxInjectProviderClass == descriptor.getDependencyType()) {
   			//javaxInjectProviderClass类注入的特殊处理
   			return new Jsr330ProviderFactory().createDependencyProvider(descriptor, requestingBeanName);
   		}
   		else {
   			Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(
   					descriptor, requestingBeanName);
   			if (result == null) {
   				//通用处理逻辑
   				result = doResolveDependency(descriptor, requestingBeanName, autowiredBeanNames, typeConverter);
   			}
   			return result;
   		}
   	}

   	public Object doResolveDependency(DependencyDescriptor descriptor, String beanName,
   			Set<String> autowiredBeanNames, TypeConverter typeConverter) throws BeansException {

   		InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);
   		try {
   			Object shortcut = descriptor.resolveShortcut(this);
   			if (shortcut != null) {
   				return shortcut;
   			}

   			//用于支持Spring中新增的注解@Value
   			Class<?> type = descriptor.getDependencyType();
   			Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
   			if (value != null) {
   				if (value instanceof String) {
   					String strVal = resolveEmbeddedValue((String) value);
   					BeanDefinition bd = (beanName != null && containsBean(beanName) ? getMergedBeanDefinition(beanName) : null);
   					value = evaluateBeanDefinitionString(strVal, bd);
   				}
   				TypeConverter converter = (typeConverter != null ? typeConverter : getTypeConverter());
   				return (descriptor.getField() != null ?
   						converter.convertIfNecessary(value, type, descriptor.getField()) :
   						converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));
   			}

   			Object multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);
   			if (multipleBeans != null) {
   				return multipleBeans;
   			}

   			//属性是数组类型或Collection类型或Map类型
   			//根据属性类型找到BeanFactory中所有类型匹配bean，
   			//返回值的构成为：key=匹配的beanName，value=beanName对应的实例化后的bean（通过getBean(beanName)返回）
   			Map<String, Object> matchingBeans = findAutowireCandidates(beanName, type, descriptor);
   			if (matchingBeans.isEmpty()) {
   				//如果autowire的require属性为true而找到的匹配项却为空则只能抛出异常
   				if (isRequired(descriptor)) {
   					raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);
   				}
   				return null;
   			}

   			String autowiredBeanName;
   			Object instanceCandidate;

   			//匹配的beanName大于1的情况
   			if (matchingBeans.size() > 1) {
   				autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);
   				if (autowiredBeanName == null) {
   					if (isRequired(descriptor) || !indicatesMultipleBeans(type)) {
   						return descriptor.resolveNotUnique(type, matchingBeans);
   					}
   					else {
   						// In case of an optional Collection/Map, silently ignore a non-unique case:
   						// possibly it was meant to be an empty collection of multiple regular beans
   						// (before 4.3 in particular when we didn't even look for collection beans).
   						return null;
   					}
   				}
   				instanceCandidate = matchingBeans.get(autowiredBeanName);
   			}
   			else {
   				// We have exactly one match.
   				//只有一个匹配项
   				Map.Entry<String, Object> entry = matchingBeans.entrySet().iterator().next();
   				autowiredBeanName = entry.getKey();
   				instanceCandidate = entry.getValue();
   			}

   			if (autowiredBeanNames != null) {
   				autowiredBeanNames.add(autowiredBeanName);
   			}
   			return (instanceCandidate instanceof Class ?
   					descriptor.resolveCandidate(autowiredBeanName, type, this) : instanceCandidate);
   		}
   		finally {
   			ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);
   		}
   	}
   ```

   - 寻找类型的匹配执行顺序是，首先尝试使用解析器进行解析。
   - 如果解析器没有成功解析，那可能是使用默认的解析器没做任何处理，或者使用了自定义解析器。
   - 但是对于集合等类型来说并不在解析范围之内，所以在此对不同类型进行不同情况处理。
   - 对于不同集合类型处理方式是一致。

3. applyPropertyValues

   - 程序已经完成了对所有注入属性的获取，但是获取的属性是以PropertyValues形式存在的，还并没有应用到已经实例化的bean中，这一工作是在applyPropertyValues中。

   ```Java
   	protected void applyPropertyValues(String beanName, BeanDefinition mbd, BeanWrapper bw, PropertyValues pvs) {
   		if (pvs == null || pvs.isEmpty()) {
   			return;
   		}

   		MutablePropertyValues mpvs = null;
   		List<PropertyValue> original;

   		if (System.getSecurityManager() != null) {
   			if (bw instanceof BeanWrapperImpl) {
   				((BeanWrapperImpl) bw).setSecurityContext(getAccessControlContext());
   			}
   		}

   		if (pvs instanceof MutablePropertyValues) {
   			mpvs = (MutablePropertyValues) pvs;
   			//如果mpvs中的值已经被转换为对应的类型那么可以直接设置到beanwapepr中
   			if (mpvs.isConverted()) {
   				// Shortcut: use the pre-converted values as-is.
   				try {
   					bw.setPropertyValues(mpvs);
   					return;
   				}
   				catch (BeansException ex) {
   					throw new BeanCreationException(
   							mbd.getResourceDescription(), beanName, "Error setting property values", ex);
   				}
   			}
   			original = mpvs.getPropertyValueList();
   		}
   		else {
   			//如果pvs并不是使用MutablePropertyValues封装的类型，那么直接使用原始的属性获取方法
   			original = Arrays.asList(pvs.getPropertyValues());
   		}

   		TypeConverter converter = getCustomTypeConverter();
   		if (converter == null) {
   			converter = bw;
   		}
   		//获取对应的解析器
   		BeanDefinitionValueResolver valueResolver = new BeanDefinitionValueResolver(this, beanName, mbd, converter);

   		// Create a deep copy, resolving any references for values.
   		List<PropertyValue> deepCopy = new ArrayList<PropertyValue>(original.size());
   		boolean resolveNecessary = false;
   		//遍历属性，将属性转换为对应类的对应属性的类型
   		for (PropertyValue pv : original) {
   			if (pv.isConverted()) {
   				deepCopy.add(pv);
   			}
   			else {
   				String propertyName = pv.getName();
   				Object originalValue = pv.getValue();
   				Object resolvedValue = valueResolver.resolveValueIfNecessary(pv, originalValue);
   				Object convertedValue = resolvedValue;
   				boolean convertible = bw.isWritableProperty(propertyName) &&
   						!PropertyAccessorUtils.isNestedOrIndexedProperty(propertyName);
   				if (convertible) {
   					convertedValue = convertForProperty(resolvedValue, propertyName, bw, converter);
   				}
   				// Possibly store converted value in merged bean definition,
   				// in order to avoid re-conversion for every created bean instance.
   				if (resolvedValue == originalValue) {
   					if (convertible) {
   						pv.setConvertedValue(convertedValue);
   					}
   					deepCopy.add(pv);
   				}
   				else if (convertible && originalValue instanceof TypedStringValue &&
   						!((TypedStringValue) originalValue).isDynamic() &&
   						!(convertedValue instanceof Collection || ObjectUtils.isArray(convertedValue))) {
   					pv.setConvertedValue(convertedValue);
   					deepCopy.add(pv);
   				}
   				else {
   					resolveNecessary = true;
   					deepCopy.add(new PropertyValue(pv, convertedValue));
   				}
   			}
   		}
   		if (mpvs != null && !resolveNecessary) {
   			mpvs.setConverted();
   		}

   		// Set our (possibly massaged) deep copy.
   		try {
   			bw.setPropertyValues(new MutablePropertyValues(deepCopy));
   		}
   		catch (BeansException ex) {
   			throw new BeanCreationException(
   					mbd.getResourceDescription(), beanName, "Error setting property values", ex);
   		}
   	}
   ```

4. 初始化bean

   - 在bean；配置时bean中有一个init-method的属性，这个属性的作用是在bean实例化前调用init-method指定的方法来根据用户业务进行相应的实例化。
   - 下面开始进入这个方法了，这个方法的执行位置位于Spring中程序已经执行过bean的实例化，并且进行了属性的填充，而就在这时将会调用用户设定的初始化方法。

   ```Java
   	//AbstractAutowireCapableBeanFactory
   	protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) {
   		if (System.getSecurityManager() != null) {
   			AccessController.doPrivileged(new PrivilegedAction<Object>() {
   				@Override
   				public Object run() {
   					invokeAwareMethods(beanName, bean);
   					return null;
   				}
   			}, getAccessControlContext());
   		}
   		else {
   			//对特殊的bean处理：Aware、BeanClassLoaderAware、BeanFactoryAware
   			invokeAwareMethods(beanName, bean);
   		}

   		Object wrappedBean = bean;
   		if (mbd == null || !mbd.isSynthetic()) {
   			//应用后处理
   			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
   		}

   		try {
   			//激活用户自定义的init方法
   			invokeInitMethods(beanName, wrappedBean, mbd);
   		}
   		catch (Throwable ex) {
   			throw new BeanCreationException(
   					(mbd != null ? mbd.getResourceDescription() : null),
   					beanName, "Invocation of init method failed", ex);
   		}

   		if (mbd == null || !mbd.isSynthetic()) {
   			//后处理器应用
   			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
   		}
   		return wrappedBean;
   	}
   ```

   - 此函数的主要目的是进行客户设定的初始化方法的调用，但是除此之外还有些其他必要的工作。

   1. 激活Aware方法

      - Spring中提供了一些Aware相关接口，比如BeanFactoryAware、ApplicationContextAware、ResourceLoaderAware、ServletContextAware等。
      - 实现这些Aware接口的bean在被初始化之后，可以取得一些相对应的资源。
      - 例如说实现BeanFactoryAware的bean在初始化后，Spring容器将会注入BeanFactory的实例，而实现ApplicationContextAware的bean，在bean被初始化，将会被注入ApplicationContext的实例等。
      - 下面通过示例方法来了解一下Aware的使用。

      1. 定义普通 bean。

      ```Java
      public class Hello {
          public void say() {
              System.out.println("hello");
          }
      }
      ```

      2. 定义BeanFactoryAware类型的bean。

      ```Java
      public class Test implements BeanFactoryAware {
          private BeanFactory beanFactory;

          //声明bean的时候Spring会自动注入BeanFactory
          @Override
          public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
              this.beanFactory = beanFactory;
          }

          public void testAware() {
              //通过hello这个bean id从beanFactory获取实例
              Hello hello = (Hello) beanFactory.getBean("hello");
              hello.say();
          }
      }
      ```

      - 运行测试类，控制台输出：

      ```Control
      hello
      ```

      - 按照上面的方法我们可以获取到Spring中BeanFactory，并且可以根据BeanFactory获取所有bean，以及进行相关设置。
      - 当前还有其他Aware的使用方法都大同小异。

      ```Java
      	//AbstractAutowireCapableBeanFactory
      	private void invokeAwareMethods(final String beanName, final Object bean) {
      		if (bean instanceof Aware) {
      			if (bean instanceof BeanNameAware) {
      				((BeanNameAware) bean).setBeanName(beanName);
      			}
      			if (bean instanceof BeanClassLoaderAware) {
      				((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());
      			}
      			if (bean instanceof BeanFactoryAware) {
      				((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this);
      			}
      		}
      	}
      ```

   2. 处理器的应用

      - BeanPostProcessor是Spring中开放式架构中一个必不可少的亮点，给用户充足的权限去更改或者扩展Spring，而除了BeanPostProcesser歪还有很多其他的PostProcessor，大部分以此为基础，继承自BeanPostProcesser。
      - BeanPostProcesser使用位置就是这里，在调用客户自定义初始化方法前以及调用自定义初始化方法后分别会调用BeanPostProcesser的postProcessBeforeInitialization和postProcessAfterInitialization方法，使用户可以根据自己的业务需求进行相应的处理。

      ```Java
      	//AbstractAutowireCapableBeanFactory
      	@Override
      	public Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName)
      			throws BeansException {

      		Object result = existingBean;
      		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      			result = beanProcessor.postProcessBeforeInitialization(result, beanName);
      			if (result == null) {
      				return result;
      			}
      		}
      		return result;
      	}

      	@Override
      	public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
      			throws BeansException {

      		Object result = existingBean;
      		for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) {
      			result = beanProcessor.postProcessAfterInitialization(result, beanName);
      			if (result == null) {
      				return result;
      			}
      		}
      		return result;
      	}
      ```

   3. 激活自定义的init方法

      - 客户定制的初始化方法除了我们熟知的使用配置init-method外，还有使自定义的bean实现InitializingBean接口，并在afterPropertiesSet中实现自己的初始化业务逻辑。
      - init-method与afterPropertiesSet都是在初始化bean时执行，执行顺序是afterPropertiesSet先执行，而init-method后执行。
      - 在invokeInitMethods方法中就实现了这两个步骤的初始化方法调用。

      ```Java
      	//AbstractAutowireCapableBeanFactory
      	protected void invokeInitMethods(String beanName, final Object bean, RootBeanDefinition mbd)
      			throws Throwable {
      		//首先会检查是否是InitializingBean，如果是的话需要调用afterPropertiesSet方法
      		boolean isInitializingBean = (bean instanceof InitializingBean);
      		if (isInitializingBean && (mbd == null || !mbd.isExternallyManagedInitMethod("afterPropertiesSet"))) {
      			if (logger.isDebugEnabled()) {
      				logger.debug("Invoking afterPropertiesSet() on bean with name '" + beanName + "'");
      			}
      			if (System.getSecurityManager() != null) {
      				try {
      					AccessController.doPrivileged(new PrivilegedExceptionAction<Object>() {
      						@Override
      						public Object run() throws Exception {
      							((InitializingBean) bean).afterPropertiesSet();
      							return null;
      						}
      					}, getAccessControlContext());
      				}
      				catch (PrivilegedActionException pae) {
      					throw pae.getException();
      				}
      			}
      			else {
      				((InitializingBean) bean).afterPropertiesSet();
      			}
      		}

      		if (mbd != null) {
      			String initMethodName = mbd.getInitMethodName();
      			if (initMethodName != null && !(isInitializingBean && "afterPropertiesSet".equals(initMethodName)) &&
      					!mbd.isExternallyManagedInitMethod(initMethodName)) {
      				//调用自定义初始化方法
      				invokeCustomInitMethod(beanName, bean, mbd);
      			}
      		}
      	}
      ```

5. 注册DisposableBean

   - Spring中不但提供了对于初始化方法的扩展入口，同样也提供了销毁方法的扩展入口，对于销毁方法的扩展，除了我们熟知的配置属性destroy-method方法外，用户还可以注册后处理器DestructionAwareBeanPostProcesser来统一处理bean的销毁方法：

   ```Java
   	//AbstractAutowireCapableBeanFactory
   	protected void registerDisposableBeanIfNecessary(String beanName, Object bean, RootBeanDefinition mbd) {
   		AccessControlContext acc = (System.getSecurityManager() != null ? getAccessControlContext() : null);
   		if (!mbd.isPrototype() && requiresDestruction(bean, mbd)) {
   			if (mbd.isSingleton()) {
   				// Register a DisposableBean implementation that performs all destruction
   				// work for the given bean: DestructionAwareBeanPostProcessors,
   				// DisposableBean interface, custom destroy method.
   				/**
   				 * 单例模式下注册需要销毁的bean，此方法中会处理时限DisposableBean的bean，
   				 * 并且对所有的bean使用DestructionAwareBeanPostProcessors处理
   				 * DisposableBeanDestructionAwareBeanPostProcessors，
   				 */
   				registerDisposableBean(beanName,
   						new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
   			}
   			else {
   				// A bean with a custom scope...
   				//自定义scope的处理
   				Scope scope = this.scopes.get(mbd.getScope());
   				if (scope == null) {
   					throw new IllegalStateException("No Scope registered for scope name '" + mbd.getScope() + "'");
   				}
   				scope.registerDestructionCallback(beanName,
   						new DisposableBeanAdapter(bean, beanName, mbd, getBeanPostProcessors(), acc));
   			}
   		}
   	}
   ```

   ​