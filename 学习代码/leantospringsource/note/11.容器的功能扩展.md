# 容器的功能扩展

- Spring中提供了ApplicationContext，用于扩展BeanFactory现有的功能。

- ApplicationContext包含BeanFactory的所有功能。

- 使用BeanFactory方式加载XML。

```Java
BeanFactory bf = new XmlBeanFactory(new ClassPathResource("beanFactoryTest.xml"));
```

- 使用ApplicationContext方式加载XML。

```Java
  ApplicationContext bf = new ClassPathXmlApplicationContext("beanFactoryTest.xml");
```

- 以ClassPathXmlApplicationContext作为切入点，开始对整体功能进行分析。

```Java
  	//ClassPathXmlApplicationContext
  	public ClassPathXmlApplicationContext(String configLocation) throws BeansException {
  		this(new String[] {configLocation}, true, null);
  	}

  	public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent)
  			throws BeansException {

  		super(parent);
  		setConfigLocations(configLocations);
  		if (refresh) {
  			refresh();
  		}
  	}
```

- 设置路径是必不可少的步骤，ClassPathXmlApplicationContext中可以将配置文件路径以数组的方式传入，ClassPathXmlApplicationContext可以对数组进行解析，而对于解析及功能实现都在`refresh()`中实现。

---

### 设置配置路径

- 在ClassPathXmlApplicationContext中支持多个配置文件以数组的方式（现在改为变长参数）同时传入。

```Java
	public void setConfigLocations(String... locations) {
		if (locations != null) {
			Assert.noNullElements(locations, "Config locations must not be null");
			this.configLocations = new String[locations.length];
			for (int i = 0; i < locations.length; i++) {
				this.configLocations[i] = resolvePath(locations[i]).trim();
			}
		}
		else {
			this.configLocations = null;
		}
	}
```

- 此函数主要用于解析给定的路径数组，如果数组中包含特殊符号，如`${var}`，那么在resolvePath中会搜寻匹配的系统变量并替换。

---

### 扩展功能

- refresh函数中包含了几乎ApplicationContext中提供的全部功能。

```Java
	//AbstractApplicationContext
	@Override
	public void refresh() throws BeansException, IllegalStateException {
		synchronized (this.startupShutdownMonitor) {
			// Prepare this context for refreshing.
			//准备刷新上下文
			prepareRefresh();

			// Tell the subclass to refresh the internal bean factory.
			//初始化BeanFactory，并进行XML文件读取
			ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

			// Prepare the bean factory for use in this context.
			//对BeanFactory进行各种功能填充
			prepareBeanFactory(beanFactory);

			try {
				// Allows post-processing of the bean factory in context subclasses.
				//子类覆盖方法做额外的处理
				postProcessBeanFactory(beanFactory);

				// Invoke factory processors registered as beans in the context.
				//激活各种BeanFactory处理器
				invokeBeanFactoryPostProcessors(beanFactory);

				// Register bean processors that intercept bean creation.
				//注册拦截Bean创建的Bean处理器，这里只是注册，真正的调用是在getBean时候
				registerBeanPostProcessors(beanFactory);

				// Initialize message source for this context.
				//为上下文初始化Message源，即不同语言的消息体，国际化处理
				initMessageSource();

				// Initialize event multicaster for this context.
				//初始化应用消息广播器，并放入“applicationEventMulticaster”bean中
				initApplicationEventMulticaster();

				// Initialize other special beans in specific context subclasses.
				//留给子类来初始化其他的Bean
				onRefresh();

				// Check for listener beans and register them.
				//在所有注册的bean中查找Listener bean,注册到消息广播器中
				registerListeners();

				// Instantiate all remaining (non-lazy-init) singletons.
				//初始化剩下的单实例（非惰性的）
				finishBeanFactoryInitialization(beanFactory);

				// Last step: publish corresponding event.
				//完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefreshEvent通知别人
				finishRefresh();
			}

			catch (BeansException ex) {
				if (logger.isWarnEnabled()) {
					logger.warn("Exception encountered during context initialization - " +
							"cancelling refresh attempt: " + ex);
				}

				// Destroy already created singletons to avoid dangling resources.
				destroyBeans();

				// Reset 'active' flag.
				cancelRefresh(ex);

				// Propagate exception to caller.
				throw ex;
			}

			finally {
				// Reset common introspection caches in Spring's core, since we
				// might not ever need metadata for singleton beans anymore...
				resetCommonCaches();
			}
		}
	}
```

- 概括一下ClassPathXmlApplicationContext初始化的步骤，并从中解释一下它所提供的功能：
  1.  初始化前的准备工作，例如对系统属性或者环境变量进行准备及验证。
     - 在某种情况下项目的使用需要读取某些系统变量，而这个变量的设置很可能会影响着系统的正确性，那么ClassPathXmlApplicationContext为我们提供的这个准备函数就显得非常必要，它可以在Spring启动的时候提前对必须的变量进行存在性验证。
  2.  初始化BeanFactory，并进行XML文件读取。
     - 在这一步骤将会复用BeanFactory中的配置文件读取解析及其他功能，这一步之后，ClassPathXmlApplicationContext实际上已经包含了BeanFactory所提供的功能，可以进行Bean的提取等基础操作了。
  3.  对BeanFactory进行各种功能填充。
     - @Qualifier与@Autowire注解正是在这一步骤中增加的支持。
  4.  子类覆盖方法做额外的处理。
     - Spring除了它功能上为大家提供了便利外，还有一方面是它的完美架构，开放式架构让使用它的程序员很容易根据业务需求扩展已经存在的功能。
     - 这种开放式设计在Spring中随处可见，在本例中就提供了一个空的函数实现postProcessBeanFactory来方便在业务上做进一步扩展。
  5.  激活各种BeanFactory处理器。
  6.  注册拦截bean创建的bean处理器，这里只是注册，真正的调用是在getBean时候。
  7.  为上下文初始化Message源，即对不同语言的消息体进行国际化处理。
  8.  初始化应用消息的广播器，并放入“applicationEventMulticaster”bean中。
  9.  留给子类来初始化其他的bean。
  10.  在所有注册的bean中查找listener bean，注册到消息广播器中。
  11.  初始化剩下的单实例（非惰性的）。
  12.  完成刷新过程，通知生命周期处理器lifecycleProcessor刷新过程，同时发出ContextRefereshEvent通知别人。

---

### 环境准备

- prepareRefresh函数主要是做些准备工作，例如对系统属性及环境变量的初始化及验证。

```Java
	//AbstractApplicationContext
	protected void prepareRefresh() {
		this.startupDate = System.currentTimeMillis();
		this.closed.set(false);
		this.active.set(true);

		if (logger.isInfoEnabled()) {
			logger.info("Refreshing " + this);
		}

		// Initialize any placeholder property sources in the context environment
		//留给子类覆盖
		initPropertySources();

		// Validate that all properties marked as required are resolvable
		// see ConfigurablePropertyResolver#setRequiredProperties
		//验证需要的属性文件是否都已经放在环境中
		getEnvironment().validateRequiredProperties();

		// Allow for the collection of early ApplicationEvents,
		// to be published once the multicaster is available...
		this.earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();
	}
```

1. initPropertySources符合Spring的开放式结构设计，用户可以根据自身的需要重写initPropertySources方法，并在方法中进行个性化的属性处理及设置。

2. validateRequiredProperties则是对属性进行验证。

   - 假如有这样一个需求，工程在运行过程中用到某个设置（例如VAR）是从系统环境变量取得，如果用户没有在系统环境变量中配置这个参数，那么工程可能不会工作。
   - 在Spring中可以直接修改源码，如修改ClassPathXmlApplicationContext。当然，最好的办法还是对源码进行扩展，可以自定义类：

   ```Java
   public class MyClassPathXmlApplicationContext extends ClassPathXmlApplicationContext {
   	public MyClassPathXmlApplicationContext(String... configLocations) {
   		super(configLocations);
   	}
     
   	protected void initPropertySources() {
   		//添加验证要求
   		getEnvironment().setRequiredProperties("VAR");
   	}
   }
   ```

   - 自定义继承自ClassPathXmlApplicationContext的MyClassPathXmlApplicationContext，并重写initPropertySources方法，在方法中添加我们的个性化需求。
   - 在验证的时候（程序走到getEnvironment().validateRequiredProperties()代码的时候），如果系统并没有检测到对应VAR的环境变量，那么将抛出异常。

---

### 加载BeanFactory

- obtainFreshBeanFactory方法从字面理解是获取BeanFactory。
- ApplicationContext是对BeanFactory的功能上的扩展，包含了BeanFactory的全部功能并在其基础上添加了大量的扩展应用，obtainFreshBeanFactory正是实现BeanFactory的地方。
- 经过这个函数后ApplicationContext就已经拥有了BeanFactory的全部功能。

```Java
	//AbstractApplicationContext
	protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
		//初始化BeanFactory，并进行XML文件读取，并将得到的BeanFactory记录在当前实体的属性中
		refreshBeanFactory();
		//返回当前实体的BeanFactory属性
		ConfigurableListableBeanFactory beanFactory = getBeanFactory();
		if (logger.isDebugEnabled()) {
			logger.debug("Bean factory for " + getDisplayName() + ": " + beanFactory);
		}
		return beanFactory;
	}
```

- 方法中将核心实现委托给了refreshBeanFactory：

```Java
	//AbstractRefreshableApplicationContext
	@Override
	protected final void refreshBeanFactory() throws BeansException {
		if (hasBeanFactory()) {
			destroyBeans();
			closeBeanFactory();
		}
		try {
			//创建DefaultListableBeanFactory
			DefaultListableBeanFactory beanFactory = createBeanFactory();
			//为了序列化指定id，如果需要的话，让这个BeanFactory从id反序列化到BeanFactory对象
			beanFactory.setSerializationId(getId());
			//定制beanFactory，设置相关属性，包括是否允许覆盖同名称的不同定义的对象以及循环依赖以及CandiateResolver
			customizeBeanFactory(beanFactory);
			//初始化DodumentReader，并进行XML文件读取及解析
			loadBeanDefinitions(beanFactory);
			synchronized (this.beanFactoryMonitor) {
				this.beanFactory = beanFactory;
			}
		}
		catch (IOException ex) {
			throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
		}
	}
```

- 上面的每个步骤：
  1. 创建DefaultListableBeanFactory。
     - BeanFactory的声明方式为：BeanFactory bf = new XMLBeanFactory("beanFactory.xml")，其中的XmlBeanFactory继承自DefaultListableBeanFactory，并提供了XMLBeanDefinitionReader类型的reader属性，DefaultListableBeanFactory是容器的基础。
  2. 指定序列化ID。
  3. 定制BeanFactory。
  4. 加载BeanDefinition。
  5. 使用全局变量记录BeanFactory类实例。
     - 因为DefaultListableBeanFactory类型的变量beanFactory是函数内的局部变量，所以要使用全局变量记录解析结果。

##### 定制BeanFactory

- 这里已经开始了对BeanFactory的扩展，在基本容器的基础上，增加了是否允许覆盖是否允许扩展的设置并提供了注解@Qualifier和@Autowired的支持。

```Java
	//AbstractRefreshableApplicationContext
	protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {
		//如果属性allowBeanDefinitionOverriding不为空，设置给beanFactory对象相应属性，
		//此属性的含义：是否允许覆盖同名称的不同定义的对象
		if (this.allowBeanDefinitionOverriding != null) {
			beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
		}
		//如果属性allowCircularReferences不为空，设置给beanFactory对象响应属性，
		//此属性的含义：是否允许bean之间存在循环依赖
		if (this.allowCircularReferences != null) {
			beanFactory.setAllowCircularReferences(this.allowCircularReferences);
		}
		//旧版还有一个方法
		//用于@Qualifier和@Autowired
		//beanFactory。setAutowireCandidateResolver(new QualifierAnnotationAutowireCandidateResolver());
	}
```

- 对于允许覆盖和允许依赖的设置这里只是判断了是否为空，如果不为空要进行设置，使用子类覆盖方法进行设置，例如：

```Java
public class MyClassPathXmlApplicationContext extends ClassPathXmlApplicationContext {
	……
    protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {
    	super.setAllowBeanDefinitionOverriding(false);
    	super.setAllowCircularReferences(false);
    	super.customizeBeanFactory(beanFactory);
    }
}
```

- 对于定制BeanFactory，Spring还提供了另外一个重要的扩展，就是设置AutowireCandidateResolver，在bean加载部分中讲解创建Bean时，如果采用AutowireByType方式注入，那么默认会使用Spring提供的SimpleAutowireCandidateResolver，而对于默认的实现并没有过多的逻辑处理。
- 在这里Spring使用了QualifierAnnotationAutowireCandidateResolver，设置了这个解析器后Spring就可以支持注解方式的注入了。（新版并不在这个函数中设置解析器，是在`customizeBeanFactory(beanFactory);`的下一个函数`loadBeanDefinitions(beanFactory);`中进行设置的，设置的是继承了`QualifierAnnotationAutowireCandidateResolver`的`ContextAnnotationAutowireCandidateResolver`）。
- 解析autowire类型时首先会调用方法：

```Java
Object value = getAutowireCandidateResolver().getSuggestedValue(descriptor);
```

- 因此，在QualifierAnnotationAutowireCandidateResolver中一定会提供了解析Qualifier与Autowire注解的方式。

```Java
	//QualifierAnnotationAutowireCandidateResolver
	public Object getSuggestedValue(DependencyDescriptor descriptor) {
		Object value = findValue(descriptor.getAnnotations());
		if (value == null) {
			MethodParameter methodParam = descriptor.getMethodParameter();
			if (methodParam != null) {
				value = findValue(methodParam.getMethodAnnotations());
			}
		}
		return value;
	}
```

##### 加载BeanDefinition

- 初始化XMLBeanFactoryReader：

```Java
	//AbstractXmlApplicationContext
	@Override
	protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
		// Create a new XmlBeanDefinitionReader for the given BeanFactory.
		//为指定beanFactory创建XMLBeanDefinitionReader
		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

		// Configure the bean definition reader with this context's
		// resource loading environment.
		//对beanDefinitionReader进行环境变量的设置
		beanDefinitionReader.setEnvironment(this.getEnvironment());
		beanDefinitionReader.setResourceLoader(this);
		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

		// Allow a subclass to provide custom initialization of the reader,
		// then proceed with actually loading the bean definitions.
		//对BeanDefinitionReader进行设置，可以覆盖
		initBeanDefinitionReader(beanDefinitionReader);
		loadBeanDefinitions(beanDefinitionReader);
	}
```

- 在初始化了DefaultListableBeanFactory和XMLBeanDefinitionReader后就可以进行配置文件的读取了。

```Java
	//AbstractXmlApplicationContext
	protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
		Resource[] configResources = getConfigResources();
		if (configResources != null) {
			reader.loadBeanDefinitions(configResources);
		}
		String[] configLocations = getConfigLocations();
		if (configLocations != null) {
			reader.loadBeanDefinitions(configLocations);
		}
	}
```

- 使用XMLBeanDefinition的loadBeanDefinitions方法进行配置文件的加载机注册，在XmlBeanDefinitionReader中已经将之前初始化的DefaultListableBeanFactory注册进去了，所以XmlBeanDefinitionReader读取的BeanDefinitionHolder都会注册到DefaultListableBeanFactory中，经过此步骤，类型DefaultListableBeanFactory的变量beanFactory已经包含了所有解析好的配置。

---

### 功能扩展

- 进入函数prepareBeanFactory前，Spring已经完成了对配置的解析，而ApplicationContext在功能上的扩展也由此展开了。

```Java
	//AbstractApplicationContext
	protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
		// Tell the internal bean factory to use the context's class loader etc.
		//设置beanFactory的classLoader为当前context的classLoader
		beanFactory.setBeanClassLoader(getClassLoader());
		//设置beanFactory的表达式语言处理器，Spring3增加了表达式语言的支持，
		//默认可以使用#{bean.xxx}的形式来调用相关属性值
		beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
		//为beanFactory增加了一个默认的propertyEditor，这个主要是对bean的属性等设置管理的一个工具
		beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

		// Configure the bean factory with context callbacks.
		//添加BeanPostProcesser
		beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
		//设置结果忽略自动装配的接口
		beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
		beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
		beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
		beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
		beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

		// BeanFactory interface not registered as resolvable type in a plain factory.
		// MessageSource registered (and found for autowiring) as a bean.
		beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
		beanFactory.registerResolvableDependency(ResourceLoader.class, this);
		beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
		beanFactory.registerResolvableDependency(ApplicationContext.class, this);

		// Register early post-processor for detecting inner beans as ApplicationListeners.
		beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

		// Detect a LoadTimeWeaver and prepare for weaving, if found.
		//增加对AspectJ的支持
		if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
			beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
			// Set a temporary ClassLoader for type matching.
			beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
		}

		// Register default environment beans.
		//添加默认的系统环境bean
		if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
		}
		if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
			beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
		}
	}
```

- 上面函数中主要进行了几个方面的扩展：
  - 增加对SPEL语言的支持。
  - 增加对属性编辑器的支持。
  - 增加对一些内置类，比如EnvironmentAware、MessageSourceAware的信息注入。
  - 设置了依赖功能可忽略的接口。
  - 注册一些固定依赖的属性。
  - 增加AspectJ的支持。
  - 将相关环境变量及属性注册以单例模式注册。

##### 增加SPEL语言的支持

- Spring表达式语言全称为“Spring Expression Language”，缩写为“SpEL”，类似于Struts 2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性。对象方法调用等，并且能与Spring功能完美整合，比如能用来配置bean定义。
- SpEL是单独模块，只依赖于core模块，可以单独使用。
- SpEL使用#{…}作为定界符，所有在大括号中的字符都将被认为是SpEL，使用格式如下：

```XML
<bean id="test" class="com.xxx.xxx.Xxx"/>
<bean id="xxx" class="com.xxx.xxx.Xxx">
	<property name="instrument" value="#{test}"/>
</bean>
```

- 相当于：

```XML
<bean id="test" class="com.xxx.xxx.Xxx"/>
<bean id="xxx" class="com.xxx.xxx.Xxx">
	<property name="instrument" ref="test"/>
</bean>
```

- SpEL功能非常强大，使用好可以大大提高开发效率。
- 在源码中通过代码beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver())注册语言解析器，就可以对SpEL进行解析了。
- Spring在bean进行初始化的时候会有属性填充的一步，在这一步中，Spring会调用AbstractAutowireCapableBeanFactory类的applyPropertyValues函数来完成功能。
- 在这个函数中，会通过构造BeanDefinitionValueResolver类型实例valueResolver来进行属性值的解析。
- 在这个步骤中一般通过AbstractBeanFactory中的evaluateBeanDefinitionString方法对完成SpEL的解析。

```Java
	//AbstractBeanFactory
	protected Object evaluateBeanDefinitionString(String value, BeanDefinition beanDefinition) {
		if (this.beanExpressionResolver == null) {
			return value;
		}
		Scope scope = (beanDefinition != null ? getRegisteredScope(beanDefinition.getScope()) : null);
		return this.beanExpressionResolver.evaluate(value, new BeanExpressionContext(this, scope));
	}
```

- 当调用这个方法时会判断是否存在语言解析器，如果存在则调用语言解析器的方法进行解析，解析的过程是在Spring的expression的包内。
- 通过查看对evaluateBeanDefinitionString方法的调用层次可以看出，应用语言解析器的调用主要是在解析依赖注入bean的时候， 以及在完成bean的初始化和属性获取后进行属性填充的时候。

##### 增加属性注册编辑器

- 在Spring DI注入的时候可以把普通属性注入进行，但是像Date类型就无法被识别。例如：

```Java
public class UserManager {
	private Date dataValue;
  
	public Date getDataValue() {
    	return dataValue;
	}
  
	public void setDataValue(Date dataValue) {
    	this.dataValue = dataValue;
	}
  
	public String toString() {
    	return "dataValue:" + dataValue;
	}
}
```

- 上面代码中，需要对日期型属性进行注入：

```XML
<bean id="userManager" class="com.test.UserManager">
    <property name="dataValue">
        <value>2013-03-15</value>
    </property>
</bean>
```

- 测试代码：

```Java
@Test
public void testDate() {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("com/test/applicationContext.xml");
    UserManager userManager = (UserManager) ctx.getBean("userManager");
    System.out.println(userManager);
}
```

- 如果直接这样使用，程序会报异常，类型转换不成功。因为在UserManager中的dataValue属性是Date类型的，而在XML中配置的却是String类型。
- Spring针对此问题提供了两种解决办法。

1. 使用自定义属性编辑器。

   - 使用自定义属性编辑器，通过继承PropertyEditorSupport，重写setAsText方法。

   1. 编写自定义的属性编辑器。

   ```Java
   public class DatePropertyEditor extends PropertyEditorSupport {

       private String format = "yyyy-MM-dd";

       public void setFormat(String format) {
           this.format = format;
       }

       public void setAsText(String arg0) {
           System.out.println("arg0:" + arg0);
           SimpleDateFormat sdf = new SimpleDateFormat(format);
           try {
               Date date = sdf.parse(arg0);
               this.setValue(date);
           } catch (ParseException e) {
               e.printStackTrace();
           }
       }
   }
   ```

   2. 将自定义属性编辑器注册到Spring中。

   ```XML
   <bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
       <property name="customEditors">
           <map>
               <entry key="java.util.Date" value="com.test.DatePropertyEditor"/>
           </map>
       </property>
   </bean>
   ```

   - 在配置文件中引入类型为org.springFramework.beans.factory.config.CustomEditorConfigurer的bean，并在属性customEditors中加入自定义的属性编辑器，其中key为属性编辑器所对应的类型。
   - 通过这样的配置，当Spring在注入bean的属性时一旦遇到了java.util.Date类型的属性会自定调用自定义的DatePropertyEditor解析器进行解析，并用解析结果代替配置属性进行注入。

2. 注册Spring自带的属性编辑器CustomDateEditor

   - 通过注册Spring自带的属性编辑器CustomDateEditor，具体步骤如下：

   1. 定义属性编辑器。

   ```Java
   <bean class="org.springframework.beans.factory.config.CustomEditorConfigurer">
       <property name="propertyEditorRegistrars">
           <list>
               <bean class="com.test.DatePropertyEditorRegistrar"/>
           </list>
       </property>
   </bean>
   ```

   - 通过在配置文件将自定义的DatePropertyEditorRegistrar注册进入org.springframework.beans.factory.config.CustomEditorConfigurer的propertyEditorRegistrars属性中，可以具有与方法1同样的效果。
   - 在注册自定义属性编辑器的时候使用的是`PropertyEditorRegistry#registerCustomEditor`方法，而这里使用的是`ConfigurableListableBeanFactory#addPropertyEditorRegistrar`方法。
   - 深入探索一下ResourceEditorRegistrar的内部实现，其中最关心的时候registerCustomEditors。

   ```Java
   //ResourceEditorRegistrar
   @Override
   public void registerCustomEditors(PropertyEditorRegistry registry) {
       ResourceEditor baseEditor = new ResourceEditor(this.resourceLoader, this.propertyResolver);
       doRegisterEditor(registry, Resource.class, baseEditor);
       doRegisterEditor(registry, ContextResource.class, baseEditor);
       doRegisterEditor(registry, InputStream.class, new InputStreamEditor(baseEditor));
       doRegisterEditor(registry, InputSource.class, new InputSourceEditor(baseEditor));
       doRegisterEditor(registry, File.class, new FileEditor(baseEditor));
       if (pathClass != null) {
           doRegisterEditor(registry, pathClass, new PathEditor(baseEditor));
       }
       doRegisterEditor(registry, Reader.class, new ReaderEditor(baseEditor));
       doRegisterEditor(registry, URL.class, new URLEditor(baseEditor));

       ClassLoader classLoader = this.resourceLoader.getClassLoader();
       doRegisterEditor(registry, URI.class, new URIEditor(classLoader));
       doRegisterEditor(registry, Class.class, new ClassEditor(classLoader));
       doRegisterEditor(registry, Class[].class, new ClassArrayEditor(classLoader));

       if (this.resourceLoader instanceof ResourcePatternResolver) {
           doRegisterEditor(registry, Resource[].class,
                   new ResourceArrayPropertyEditor((ResourcePatternResolver) this.resourceLoader, this.propertyResolver));
       }
   }

   private void doRegisterEditor(PropertyEditorRegistry registry, Class<?> requiredType, PropertyEditor editor) {
       if (registry instanceof PropertyEditorRegistrySupport) {
           ((PropertyEditorRegistrySupport) registry).overrideDefaultEditor(requiredType, editor);
       }
       else {
           registry.registerCustomEditor(requiredType, editor);
       }
   }
   ```

   - 在doRegisterEditor函数中，可以看到之前提到自定义属性中使用的关键代码：`registry.registerCustomEditor(requiredType, editor)`。
   - ResourceEditorRegistrar类的registerCustomEditors方法的核心功能，无非是注册了一系列的常用类型的属性编辑器。
   - 例如，代码`doRegisterEditor(registry, Class.class, new ClassEditor(classLoader))`实现的功能就是注册Class类对应的属性编辑器。  
   - 注册后，一旦某个实体bean中存在一些Class类型的属性，那么Spring会调用ClassEditor将配置中定义的String类型转换为Class类型并进行赋值。
   - 虽然ResourceEditorRegistrar类的registerCustomEditors方法实现了批量注册的功能，但是`beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEvironment()))`仅仅是注册了ResourceEditorRegistrar实例，却并没有调用`ResourceEditorRegistrar#registerCustomEditors`方法的调用层次结构：
   - ![](img/12.png?raw=true)
   - 发现在AbstractBeanFactory中的registerCustomEditors方法中被调用过，继续查看AbstractBeanFactory中的registerCustomEditors方法的调用层次结结构。
   - 其中我们看到一个熟悉的方法，就是`AbstractBeanFactory#initBeanWrapper`方法，这是在bean初始化时使用的一个方法，主要是在将BeanDefinition转化为BeanWrapper后用于对属性的填充。
   - 在bean的初始化后会调用`ResourceEditorRegistrar#registerCustomEditors`方法进行批量的通用属性编辑器注册。注册后，在属性填充的环境便可以直接让Spring使用这些编辑器进行属性的解析了。
   - Spring中用于封装bean的是BeanWrapper类型，而它又间接继承了PropertyEditorRegistry类型，也就是我们之前反复看到的方法参数`PropertyEditorRegistry register`其实大部分情况下都是BeanWrapper。
   - 对于BeanWrapper在Spring中默认实现是BeanWrapperImpl，而BeanWrapperImpl除了实现BeanWrapper接口外还继承了PropertyEditorRegistrySupport，在PropertyEditorRegistrySupport中有这样一个方法：

   ```Java
   private void createDefaultEditors() {
       this.defaultEditors = new HashMap<Class<?>, PropertyEditor>(64);

       // Simple editors, without parameterization capabilities.
       // The JDK does not contain a default editor for any of these target types.
       this.defaultEditors.put(Charset.class, new CharsetEditor());
       this.defaultEditors.put(Class.class, new ClassEditor());
       this.defaultEditors.put(Class[].class, new ClassArrayEditor());
       this.defaultEditors.put(Currency.class, new CurrencyEditor());
       this.defaultEditors.put(File.class, new FileEditor());
       this.defaultEditors.put(InputStream.class, new InputStreamEditor());
       this.defaultEditors.put(InputSource.class, new InputSourceEditor());
       this.defaultEditors.put(Locale.class, new LocaleEditor());
       if (pathClass != null) {
           this.defaultEditors.put(pathClass, new PathEditor());
       }
       this.defaultEditors.put(Pattern.class, new PatternEditor());
       this.defaultEditors.put(Properties.class, new PropertiesEditor());
       this.defaultEditors.put(Reader.class, new ReaderEditor());
       this.defaultEditors.put(Resource[].class, new ResourceArrayPropertyEditor());
       this.defaultEditors.put(TimeZone.class, new TimeZoneEditor());
       this.defaultEditors.put(URI.class, new URIEditor());
       this.defaultEditors.put(URL.class, new URLEditor());
       this.defaultEditors.put(UUID.class, new UUIDEditor());
       if (zoneIdClass != null) {
           this.defaultEditors.put(zoneIdClass, new ZoneIdEditor());
       }

       // Default instances of collection editors.
       // Can be overridden by registering custom instances of those as custom editors.
       this.defaultEditors.put(Collection.class, new CustomCollectionEditor(Collection.class));
       this.defaultEditors.put(Set.class, new CustomCollectionEditor(Set.class));
       this.defaultEditors.put(SortedSet.class, new CustomCollectionEditor(SortedSet.class));
       this.defaultEditors.put(List.class, new CustomCollectionEditor(List.class));
       this.defaultEditors.put(SortedMap.class, new CustomMapEditor(SortedMap.class));

       // Default editors for primitive arrays.
       this.defaultEditors.put(byte[].class, new ByteArrayPropertyEditor());
       this.defaultEditors.put(char[].class, new CharArrayPropertyEditor());

       // The JDK does not contain a default editor for char!
       this.defaultEditors.put(char.class, new CharacterEditor(false));
       this.defaultEditors.put(Character.class, new CharacterEditor(true));

       // Spring's CustomBooleanEditor accepts more flag values than the JDK's default editor.
       this.defaultEditors.put(boolean.class, new CustomBooleanEditor(false));
       this.defaultEditors.put(Boolean.class, new CustomBooleanEditor(true));

       // The JDK does not contain default editors for number wrapper types!
       // Override JDK primitive number editors with our own CustomNumberEditor.
       this.defaultEditors.put(byte.class, new CustomNumberEditor(Byte.class, false));
       this.defaultEditors.put(Byte.class, new CustomNumberEditor(Byte.class, true));
       this.defaultEditors.put(short.class, new CustomNumberEditor(Short.class, false));
       this.defaultEditors.put(Short.class, new CustomNumberEditor(Short.class, true));
       this.defaultEditors.put(int.class, new CustomNumberEditor(Integer.class, false));
       this.defaultEditors.put(Integer.class, new CustomNumberEditor(Integer.class, true));
       this.defaultEditors.put(long.class, new CustomNumberEditor(Long.class, false));
       this.defaultEditors.put(Long.class, new CustomNumberEditor(Long.class, true));
       this.defaultEditors.put(float.class, new CustomNumberEditor(Float.class, false));
       this.defaultEditors.put(Float.class, new CustomNumberEditor(Float.class, true));
       this.defaultEditors.put(double.class, new CustomNumberEditor(Double.class, false));
       this.defaultEditors.put(Double.class, new CustomNumberEditor(Double.class, true));
       this.defaultEditors.put(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, true));
       this.defaultEditors.put(BigInteger.class, new CustomNumberEditor(BigInteger.class, true));

       // Only register config value editors if explicitly requested.
       if (this.configValueEditorsActive) {
           StringArrayPropertyEditor sae = new StringArrayPropertyEditor();
           this.defaultEditors.put(String[].class, sae);
           this.defaultEditors.put(short[].class, sae);
           this.defaultEditors.put(int[].class, sae);
           this.defaultEditors.put(long[].class, sae);
       }
   }
   ```

   - 通过这个这个方法我们知道Spring定义了上面一系列常用的属性编辑器使我们可以方便地进行配置，如果我们定义的bean中的某个属性的类型不在上面的常用配置中的话，才需要我们进行个性化属性编辑器的注册。

#####  添加ApplicationContextAwareProcessor处理器

- 对于beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this))其实主要目的就是注册个BeanPostProcessor，而真正的逻辑是在ApplicationContextAwareProcessor中。
- 对于postProcessAfterInitialization方法，在ApplicationContextAwareProcessor并没有做过多逻辑处理。

```Java
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) {
    return bean;
}
```

- 重点看一下postProcessBeforeInstantiation方法。

```Java
@Override
public Object postProcessBeforeInitialization(final Object bean, String beanName) throws BeansException {
    AccessControlContext acc = null;

    if (System.getSecurityManager() != null &&
            (bean instanceof EnvironmentAware || bean instanceof EmbeddedValueResolverAware ||
                    bean instanceof ResourceLoaderAware || bean instanceof ApplicationEventPublisherAware ||
                    bean instanceof MessageSourceAware || bean instanceof ApplicationContextAware)) {
        acc = this.applicationContext.getBeanFactory().getAccessControlContext();
    }

    if (acc != null) {
        AccessController.doPrivileged(new PrivilegedAction<Object>() {
            @Override
            public Object run() {
                invokeAwareInterfaces(bean);
                return null;
            }
        }, acc);
    }
    else {
        invokeAwareInterfaces(bean);
    }

    return bean;
}

private void invokeAwareInterfaces(Object bean) {
    if (bean instanceof Aware) {
        if (bean instanceof EnvironmentAware) {
            ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment());
        }
        if (bean instanceof EmbeddedValueResolverAware) {
            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver);
        }
        if (bean instanceof ResourceLoaderAware) {
            ((ResourceLoaderAware) bean).setResourceLoader(this.applicationContext);
        }
        if (bean instanceof ApplicationEventPublisherAware) {
            ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(this.applicationContext);
        }
        if (bean instanceof MessageSourceAware) {
            ((MessageSourceAware) bean).setMessageSource(this.applicationContext);
        }
        if (bean instanceof ApplicationContextAware) {
            ((ApplicationContextAware) bean).setApplicationContext(this.applicationContext);
        }
    }
}
```

- postProcessBeforeInitialization方法中调用了invokeAwareInterfaces，实现这些Aware接口的bean在被初始化后，可以取得一些对应的资源。

##### 设置忽略依赖

- 当Spring将ApplicationContextAwareProcessor注册后，那么在invokeAwareInterfaces方法中间接调用的Aware类已经不是普通的bean了，如ResourceLoaderAware、ApplicationEventPublisherAware等，需要在Spring做bean的依赖注入的时候忽略它们。
- ignoreDependencyInterface的作用正是在此。

```Java
//设置几个忽略自动装配的接口
beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);
```

##### 注册依赖

- Spring中有忽略依赖的功能，也会有注册依赖的功能。

```Java
// BeanFactory interface not registered as resolvable type in a plain factory.
// MessageSource registered (and found for autowiring) as a bean.
beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
beanFactory.registerResolvableDependency(ResourceLoader.class, this);
beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
beanFactory.registerResolvableDependency(ApplicationContext.class, this);
```

- 当注册了依赖解析后，例如当注册了对BeanFactory.class的解析依赖后当bean的属性注入的时候，一旦检测到属性为BeanFactory类型便会将beanFactory的实例注入进去。

---

### BeanFactory的后处理

- BeanFactory作为Spring中容器功能的基础，用于存放所有已经加载的bean，为了保证程序上的高可扩展性，Spring针对BeanFactory做了大量的扩展，比如我们熟知的PostProcessor等。

##### 激活注册的BeanFactoryPostProcessor

- BeanFactoryPostProcessor接口跟BeanPostProcessor类似，可以对bean的定义（配置元数据）进行处理。
- Spring IoC容器允许BeanFactoryPostProcessor在容器实际实例化任何其他的bean之前读取配置元数据，并有可能改变它。
- 可以配置多个BeanFactoryPostProcessor，还能通过设置“order”属性来控制BeanFactoryPostProcessor的执行次序（仅当BeanFactoryPostProcessor实现了Ordered接口时才可以设置此属性）。
- 如果想改变实际的bean实例（例如从配置元数据创建的对象），最好使用BeanPostProcessor，BeanFactoryPostProcessor的作用域范围是容器级的，只和所使用的容器有关。
- 如果在容器中定义一个BeanFactoryPostProcessor，它仅仅对此容器中的bean 进行后置处理。BeanFactoryPostProcessor不会对定义在另一个容器中的bean进行后置处理，即使这两个容器都是在同一层次上。
- 在Spring中存在对于BeanFactoryPostProcessor的典型应用 ，比如PropertyPlaceholderConfigurer。

1. BeanFactoryPostProcessor的典型应用：PropertyPlaceholderConfigurer

   - 类似如下的一些配置：

   ```XML
   <bean id="message" class="distConfig.HelloMessage">
   	<proerty name="mes">
   		<value>${bean.message}</value>
     	</proerty>
   </bean>
   ```

   - 其中变量引用：${bean.message}，这就是Spring的分散配置，可以在另外的配置文件中为bean.message指定值。如在bean.property配置如下定义：

   ```properties
   bean.message=Hi,can you find me?
   ```

   - 当访问名为message的bean时，mes属性就会被置为字符串“Hi,can you find me?”，但要靠PropertyPlaceholderConfigurer这个类的bean：

   ```XML
   <bean id="mesHandler" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
   	<property name="loications">
   		<list>
   			<value>config/bean.properties</value>
   		</list>
   	</property>
   </bean>
   ```

   - 这个mesHandler只不过是Spring框架管理的一个bean，Spring的BeanFactory怎么知道要从这个bean中获取配置信息呢？
   - 查看层级结构可以看出PropertyPlaceholderConfigurer这个类间接继承了BeanFactoryPostProcessor接口。当Spring加载任何实现了这个接口的bean的配置时，都会在bean工厂载入所有bean的配置之后执行PostProcessBeanFactory方法。
   - 在PropertyPlaceholderConfigurer类中实现了PostProcessBeanFactory方法，在方法中先后调用了mergeProperties、convertProperties、processProperties这三个方法，分别得到配置，将得到的配置转换为合适的类型，最后将配置内容告知BeanFactory。

2. 使用自定义BeanFactoryPostProcessor

   - 以实现一个BeanFactoryPostProcessor为例，屏蔽特殊字符串的功能来展示自定义BeanFactoryPostProcessor的创建及使用。

   ```Java
   public class ObscenityRemovingBeanFactoryPostProcessor implements BeanFactoryPostProcessor {

       private Set<String> obscenties;

       public ObscenityRemovingBeanFactoryPostProcessor() {
           this.obscenties = new HashSet<>();
       }

       @Override
       public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
           String[] beanNames = beanFactory.getBeanDefinitionNames();
           for (String beanName :
                   beanNames) {
               BeanDefinition bd = beanFactory.getBeanDefinition(beanName);
               StringValueResolver valueResolver = new StringValueResolver() {
                   @Override
                   public String resolveStringValue(String strVal) {
                       if (isObscene(strVal)) return "*****";
                       return strVal;
                   }
               };
               BeanDefinitionVisitor visitor = new BeanDefinitionVisitor(valueResolver);
               visitor.visitBeanDefinition(bd);
           }
       }

       public boolean isObscene(Object value) {
           String potentialObscenity = value.toString().toUpperCase();
           return this.obscenties.contains(potentialObscenity);
       }

       public void setObscenties(Set<String> obscenties) {
           this.obscenties.clear();
           for (String obscenity :
                   obscenties) {
               this.obscenties.add(obscenity.toUpperCase());
           }
       }
   }

   public class SimplePostProcessor {

       private String connectionString;
       private String username;
       private String  password;

   	//以下省略get/set方法和toString方法
   }

   public class PropertyConfigurerDemo {

       public static void main(String[] args) {

           ConfigurableListableBeanFactory bf =  new XmlBeanFactory(new ClassPathResource("com/postprocessor/BeanFactory.xml"));

           BeanFactoryPostProcessor bfpp = (BeanFactoryPostProcessor) bf.getBean("bfpp");
           bfpp.postProcessBeanFactory(bf);
           System.out.println(bf.getBean("simpleBean"));
       }
   }
   ```

   ```XML
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
                              http://www.springframework.org/schema/beans/spring-beans.xsd">

       <bean id="bfpp" class="com.postprocessor.ObscenityRemovingBeanFactoryPostProcessor">
           <property name="obscenties">
               <set>
                   <value>bollocks</value>
                   <value>winky</value>
                   <value>bum</value>
                   <value>Microsoft</value>
               </set>
           </property>
       </bean>

       <bean id="simpleBean" class="com.postprocessor.SimplePostProcessor">
           <property name="connectionString" value="bollocks"/>
           <property name="username" value="Microsoft"/>
           <property name="password" value="imaginecup"/>
       </bean>

   </beans>
   ```

   ```Control
   SimplePostProcessor{connectionString='*****', username='*****', password='imaginecup'}
   ```

   - 通过ObscenityRemovingBeanFactoryPostProcessor，Spring很好地实现了屏蔽掉boscenties定义的不应该展示的属性。

3. 激活BeanFactoryPostProcessor

   ```Java
   //AbstractApplicationContext
   protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
       PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

       // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
       // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
       if (beanFactory.getTempClassLoader() == null && beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
           beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
           beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
       }
   }

   //PostProcessorRegistrationDelegate
   public static void invokeBeanFactoryPostProcessors(
           ConfigurableListableBeanFactory beanFactory, List<BeanFactoryPostProcessor> beanFactoryPostProcessors) {

       // Invoke BeanDefinitionRegistryPostProcessors first, if any.
       Set<String> processedBeans = new HashSet<String>();

       //对BeanDefinitionRegistry类型的处理
       if (beanFactory instanceof BeanDefinitionRegistry) {
           BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
           List<BeanFactoryPostProcessor> regularPostProcessors = new LinkedList<BeanFactoryPostProcessor>();
         
       	//BeanDefinitionRegistryPostProcessor
           List<BeanDefinitionRegistryPostProcessor> registryPostProcessors =
                   new LinkedList<BeanDefinitionRegistryPostProcessor>();

       	/**
       	 * 硬编码注册的后处理器
       	 */
           for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
               if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                   BeanDefinitionRegistryPostProcessor registryPostProcessor =
                           (BeanDefinitionRegistryPostProcessor) postProcessor;
       		   //对于BeanDefinitionRegistryPostProcessor类型，在BeanFactoryPostProcessor的基础上还有自己定义的方法，需要先调用
                   registryPostProcessor.postProcessBeanDefinitionRegistry(registry);
                   registryPostProcessors.add(registryPostProcessor);
               }
               else {
       		   //记录常规BeanFactoryPostProcessor
                   regularPostProcessors.add(postProcessor);
               }
           }

           // Do not initialize FactoryBeans here: We need to leave all regular beans
           // uninitialized to let the bean factory post-processors apply to them!
           // Separate between BeanDefinitionRegistryPostProcessors that implement
           // PriorityOrdered, Ordered, and the rest.
           //配置注册的后处理
           String[] postProcessorNames =
                   beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);

           // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
           //获取有优先级BeanDefinitionRegistryPostProcessor
           List<BeanDefinitionRegistryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
           for (String ppName : postProcessorNames) {
               if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                   priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                   processedBeans.add(ppName);
               }
           }
           //按优先级排序并注册priorityOrderedPostProcessors
           sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
           registryPostProcessors.addAll(priorityOrderedPostProcessors);
           invokeBeanDefinitionRegistryPostProcessors(priorityOrderedPostProcessors, registry);

           // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
           postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
           //获取有order的BeanDefinitionRegistryPostProcessor
           List<BeanDefinitionRegistryPostProcessor> orderedPostProcessors = new ArrayList<BeanDefinitionRegistryPostProcessor>();
           for (String ppName : postProcessorNames) {
               if (!processedBeans.contains(ppName) && beanFactory.isTypeMatch(ppName, Ordered.class)) {
                   orderedPostProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                   processedBeans.add(ppName);
               }
           }
           //按order排序并注册orderedPostProcessors
           sortPostProcessors(beanFactory, orderedPostProcessors);
           registryPostProcessors.addAll(orderedPostProcessors);
           invokeBeanDefinitionRegistryPostProcessors(orderedPostProcessors, registry);

           // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
           //将剩下的BeanDefinitionRegistryPostProcessor获取并注册
           boolean reiterate = true;
           while (reiterate) {
               reiterate = false;
               postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
               for (String ppName : postProcessorNames) {
                   if (!processedBeans.contains(ppName)) {
                       BeanDefinitionRegistryPostProcessor pp = beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class);
                       registryPostProcessors.add(pp);
                       processedBeans.add(ppName);
                       pp.postProcessBeanDefinitionRegistry(registry);
                       reiterate = true;
                   }
               }
           }

           // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
           //激活PostProcessBeanFactory方法，之前激活的是postProcessBeanDefinitionRegistry
           //硬编码设置的BeanDefinitionRegistryPostProcessor
           invokeBeanFactoryPostProcessors(registryPostProcessors, beanFactory);
           //常规BeanFactoryPostProcessor
           invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
       }

       else {
           // Invoke factory processors registered with the context instance.
           invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
       }

       // Do not initialize FactoryBeans here: We need to leave all regular beans
       // uninitialized to let the bean factory post-processors apply to them!
       //对于配置中读取的BeanFactoryPostProcessor的处理
       String[] postProcessorNames =
               beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

       // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
       // Ordered, and the rest.
       List<BeanFactoryPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
       List<String> orderedPostProcessorNames = new ArrayList<String>();
       List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
       //对后处理器进行分类
       for (String ppName : postProcessorNames) {
           if (processedBeans.contains(ppName)) {
   		    //已经处理过
               // skip - already processed in first phase above
           }
           else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
               priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
           }
           else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
               orderedPostProcessorNames.add(ppName);
           }
           else {
               nonOrderedPostProcessorNames.add(ppName);
           }
       }

       // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
       //按照优先级进行排序
       sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
       invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

       // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
       List<BeanFactoryPostProcessor> orderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
       for (String postProcessorName : orderedPostProcessorNames) {
           orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
       }
       //按照order排序
       sortPostProcessors(beanFactory, orderedPostProcessors);
       invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

       // Finally, invoke all other BeanFactoryPostProcessors.
       //无序，直接调用
       List<BeanFactoryPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanFactoryPostProcessor>();
       for (String postProcessorName : nonOrderedPostProcessorNames) {
           nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
       }
       invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

       // Clear cached merged bean definitions since the post-processors might have
       // modified the original metadata, e.g. replacing placeholders in values...
       beanFactory.clearMetadataCache();
   }
   ```

   - 对于BeanFactoryPostProcessor的处理主要分两种进行，一个是对于BeanDefinitionRegistry类的特殊处理，另一种是对普通的BeanFactoryPostProcessor进行处理。
   - 而对于每种情况都需要考虑硬编码注入注册的后处理器以及通过配置注入的后处理器。
   - 对于BeanDefinitionRegistry类型的处理类的处理主要包括以下内容：

   1. 对于硬编码注册的后处理器的处理，主要是听过AbstractApplicationContext中的添加处理器方法addBeanFactoryPostProcessor进行添加。

      ```Java
      //AbstractApplicationContext
      @Override
      public void addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor) {
          Assert.notNull(postProcessor, "BeanFactoryPostProcessor must not be null");
          this.beanFactoryPostProcessors.add(postProcessor);
      }
      ```

      - 添加后的后处理器会存放在BeanFactoryPostProcessors中，而在处理BeanFactoryPostProcessor时候回首先检测beanFactoryPostProcessors是否有数据。
      - BeanDefinitionRegistryPostProcessor继承自BeanFactoryPostProcessor，不但有BeanFactoryPostProcessor的特性，同时还有自己定的个性化方法，也需要在此调用。
      - 所以这里需要从beanFactoryPostProcessors中挑出BeanDefinitionRegistryPostProcessor的后处理器，并进行其postProcessBeanDefinitionRegistry方法的激活。

   2. 记录后处理器主要使用了三个List完成

      - registryPostProcessors：记录通过硬编码方式注册的BeanDefinitionRegistryPostProcessor类型的处理器。
      - regularPostProcessors：记录通过硬编码方式注册的BeanFactoryPostProcessor类型的处理器。
      - RegistryPostProcessorBeans：记录通过配置方式注册的BeanDefinitionRegistryPostProcessor类型的处理器。

   3. 对以上所记录的List中的后处理器进行统一调用BeanFactoryPostProcessor的postProcessBeanFactory方法。

   4. 对BeanFactoryPostProcessors中非BeanDefinitionRegistryPostProcessor类型的后处理器进行统一的BeanFactoryPostProcessor的postProcessBeanFactory方法调用。

   5. 普通beanFactory处理。

      - BeanDefinitionRegistryPostProcessor只对BeanDefinitionRegistry类型的ConfigurableListableBeanFactory有效，所以如果判断所示的beanFactory并不是BeanDefinitionRegistry，那么便可以忽略BeanDefinitionRegistryPostProcessor，而直接处理BeanFactoryPostProcessor，获取的方式与上面的获取类似。
      - 对于硬编码方式手动添加的后处理器是不需要做任何排序的，在配置文件中读取的处理器，Spring并不保证读取的顺序，所以为了保证用户的调用顺序的要求，Spring对于后处理器的调用支持按照PriorityOrdered或者Ordered的顺序调用。

##### 注册BeanPostProcessor

- BeanPostProcesso`r真正的调用是在bean的实例化阶段进行的，这是一个很重要的步骤，也是很多功能BeanFactory不支持的重要原因。
- Spring中大部分功能都是通过后处理器的方式进行扩展的，这是Spring框架的一个特性，但是在BeanFactory中其实并没有实现后处理器的自动注册，所以在调用的时候如果没有进行手动注册其实是不能使用的。
- 在ApplicationContext中却添加了自动注册功能，如果自定义这样一个后处理器：

```Java
public class MyInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor {
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("====");
        return null;
    }

    ……
}
```

```XML
<bean class="com.postprocessor.MyInstantiationAwareBeanPostProcessor"/>
```

- 使用BeanFactory方式进行Spring的bean的加载时是不会有任何改变，但是使用ApplicationContext方式获取bean的时候会在获取每个bean时打印“====”，这个特性是在registerBeanPostProcessors方法中完成的。

```Java
//AbstractApplicationContext
protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
}

//PostProcessorRegistrationDelegate
public static void registerBeanPostProcessors(
        ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

    // Register BeanPostProcessorChecker that logs an info message when
    // a bean is created during BeanPostProcessor instantiation, i.e. when
    // a bean is not eligible for getting processed by all BeanPostProcessors.
	/**
	 * BeanPostProcessorChecker是一个普通的信息打印，可能会有些情况，
	 * 当Spring的配置中的后处理器还没有被注册就已经开始了bean的初始化时
	 * 便会打印出BeanPostProcesserChecker中设定的信息
	 */
    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

    // Separate between BeanPostProcessors that implement PriorityOrdered,
    // Ordered, and the rest.
	//使用 PriorityOrdered保证顺序
    List<BeanPostProcessor> priorityOrderedPostProcessors = new ArrayList<BeanPostProcessor>();
	//MergedBeanDefinitionPostProcessor
    List<BeanPostProcessor> internalPostProcessors = new ArrayList<BeanPostProcessor>();
	//使用Ordered保证顺序
    List<String> orderedPostProcessorNames = new ArrayList<String>();
	//无序的BeanPostProcesser
    List<String> nonOrderedPostProcessorNames = new ArrayList<String>();
    for (String ppName : postProcessorNames) {
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            priorityOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
            orderedPostProcessorNames.add(ppName);
        }
        else {
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    // First, register the BeanPostProcessors that implement PriorityOrdered.
	//第一步，注册所有实现PriorityOrdered的BeanPostProcesser
    sortPostProcessors(beanFactory, priorityOrderedPostProcessors);
    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

    // Next, register the BeanPostProcessors that implement Ordered.
 	//第二步，注册所有实现Ordered的BeanPostProcesser
    List<BeanPostProcessor> orderedPostProcessors = new ArrayList<BeanPostProcessor>();
    for (String ppName : orderedPostProcessorNames) {
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        orderedPostProcessors.add(pp);
        if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    sortPostProcessors(beanFactory, orderedPostProcessors);
    registerBeanPostProcessors(beanFactory, orderedPostProcessors);

    // Now, register all regular BeanPostProcessors.
  	//第三步，注册所有无序的BeanPostProcesser
    List<BeanPostProcessor> nonOrderedPostProcessors = new ArrayList<BeanPostProcessor>();
    for (String ppName : nonOrderedPostProcessorNames) {
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        nonOrderedPostProcessors.add(pp);
        if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

    // Finally, re-register all internal BeanPostProcessors.
    //第四步，注册所有MergedBeanDefinitionPostProcessor类型的BeanPostProcesser，并非重复注册
    sortPostProcessors(beanFactory, internalPostProcessors);
    registerBeanPostProcessors(beanFactory, internalPostProcessors);

    // Re-register post-processor for detecting inner beans as ApplicationListeners,
    // moving it to the end of the processor chain (for picking up proxies etc).
  	//添加ApplicationListener探测器
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
}
```

- 对于BeanPostProcesser的处理与BeanFactoryPostProcessor的处理极为相似，但又有区别。
- 对于BeanFactoryPostProcessor的处理分两种情况：
  - 一种是通过硬编码方式处理。
  - 另一种是通过配置文件方式的处理。
- 对于BeanFactoryPostProcessor的处理，不但要实现注册功能，而且 还要实现对后处理器的激活操作，所有需要载入配置中的定义，并进行激活；
- 而对于BeanPostProcesser并不需要马上调用，硬编码的方式实现的功能是将后处理器提取并调用，这里并不需要调用，这里的功能只需要将配置文件的BeanPostProcesser提取出来并注册进入beanFactory就可以了。
- 对于beanFactory的注册，在Spring中支持对于BeanPostProcesser的排序，根据PriorityOrdered、Ordered或者无序进行排序。
- 对于 internalPostProcessor中存储的后处理器也就是MergeBeanDefinitionPostProcessor类型的处理器，在代码中似乎被重复调用了。

```Java
for (String ppName : postProcessorNames) {
    if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        priorityOrderedPostProcessors.add(pp);
        if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
        orderedPostProcessorNames.add(ppName);
    }
    else {
        nonOrderedPostProcessorNames.add(ppName);
    }
}
```

- 其实不是，看看对于 registerBeanPostProcessers方法的实现方式。

```Java
//PostProcessorRegistrationDelegate
private static void registerBeanPostProcessors(
        ConfigurableListableBeanFactory beanFactory, List<BeanPostProcessor> postProcessors) {

    for (BeanPostProcessor postProcessor : postProcessors) {
        beanFactory.addBeanPostProcessor(postProcessor);
    }
}

//AbstractBeanFactory
@Override
public void addBeanPostProcessor(BeanPostProcessor beanPostProcessor) {
    Assert.notNull(beanPostProcessor, "BeanPostProcessor must not be null");
    this.beanPostProcessors.remove(beanPostProcessor);
    this.beanPostProcessors.add(beanPostProcessor);
    if (beanPostProcessor instanceof InstantiationAwareBeanPostProcessor) {
        this.hasInstantiationAwareBeanPostProcessors = true;
    }
    if (beanPostProcessor instanceof DestructionAwareBeanPostProcessor) {
        this.hasDestructionAwareBeanPostProcessors = true;
    }
}
```

- 在registerBeanPostProcessors方法的实现中其实已经确保了 beanPostProcessor的唯一性，之所以在registerBeanPostProcessors中没有进行重复移动操作或许是为了保持分类的效果，使逻辑更清晰。

##### 初始化消息资源

- Java通过java.util.Locale类表示一个本地化对象，它允许通过语言参数和国家/地区参数创建一个确定的本地化对象。
- java.util.Locale是表示语言和国家信息/地区信息的本地化类，它是创建国际化应用的基础。下面给出几个创建本地化对象的实例：

```Java
//①带有语言和国家/地区信息的本地化对象
Locale locale = new Locale("zh", "CN");

//②只有语言信息的本地化对象
Locale locale2 = new Locale("zh");

//③等同于Locale("zh", "CN")
Locale locale3 = Locale.CHINA;

//④等同于Locale("zh")
Locale locale4 = Locale.CHINESE;

//⑤获取本地系统默认的本地化对象
Locale locale = Locale.getDefault();
```

- JDK的java.util包中提供了几个支持本地化的格式化操作工具类： NumberFormat、DateFormat、MessageFormat，而在Spring中的国际化资源操作也无非是对于这些类的封装操作。
- 以下介绍MessageFormat的用法：

```Java
//①信息格式化串
String pattern1 = "{0},你好！你于{1}在工商银行存入{2}元。";
String pattern2 = "At {1,time,short} On {1,date,long}, {0} paid {2,number,currency}.";

//②用于动态替换占位符的参数
Object[] params = {"Join", new GregorianCalendar().getTime(), 1.0E3};

//③使用默认本地化对象格式化信息
String msg1 = MessageFormat.format(pattern1, params);

//④使用指定的本地化对象格式化信息
MessageFormat mf = new MessageFormat(pattern2, Locale.US);
String msg2 = mf.format(params);
System.out.println(msg1);
System.out.println(msg2);
```

- Spring定义了访问国际化信息的MessageSource接口，并提供了几个易用的实现类。

- MessageSource分别被HierarchicalMessageSource和ApplicationContext接口扩展，这里我们主要看一下HierarchicalMessageSource接口的几个实现类。

- ![](img/13.png?raw=true)

- HierarchicalMessageSource接口最重要的两个实现是ResourceBundleMessageSource和ReloadableResourceBundleMessageSource。它们基于Java的ResourceBundle基础类实现，允许仅通过资源名加载国际化资源。

- ReloadableResourceBundleMessageSource提供了定时刷新功能，允许在不重启 系统的情况下，更新资源新。StaticMessageSource主要用于程序测试，它允许通过编程的方式提供国际化信息。而DelegatingMessageSource是为了方便操作父MessageSource而提供的代理类。

- 举例ResourceBundleMessageSource的实现方式：

  1. 定义资源文件。

     - messages_en_US.properties（默认：英文），内容仅一句，如下：

     ```properties
     test=At {1,time,short} On {1,date,long}, {0} paid {2,number,currency}.
     ```

     - messages_zh_CN.properties（简体中文）：

     ```properties
     test={0},你好！你于{1}在工商银行存入{2}元。
     ```

     - 然后cmd，输入native2ascii -encoding gbk C:\messages_zh_CN.properties C:\messages_zh_CN_tem.properties，并将C:\messages_zh_CN_tem.properties中的内容替换到message_zh_CN.properties中，这样messages_zh_CN.properties文件就存放的时候转码后的内容了。

  2. 定义配置文件。

     ```XML
     <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
         <property name="defaultEncoding" value="UTF-8"/>
         <property name="basenames">
             <list>
                 <value>com/messagesource/messages</value>
             </list>
         </property>
     </bean>
     ```

     - 其中，这个Bean的ID必须命名为messageSource ，否则会抛出 NoSuchMessageException异常。

  3. 使用。通过ApplicationContext访问国际化信息。

     ```Java
     public static void main(String[] args) {
         ApplicationContext ctx = new ClassPathXmlApplicationContext("com/messagesource/applicationContext.xml");
         Object[] params = {"Join", new GregorianCalendar().getTime(), 1.0E3};

         String str1 = ctx.getMessage("test", params, Locale.US);
         String str2 = ctx.getMessage("test", params, Locale.CHINA);
         System.out.println(str1);
         System.out.println(str2);
     }
     ```

     ```Control
     At 7:18 PM On August 2, 2017, Join paid $1,000.00.
     Join,你好！你于17-8-2 下午7:18在工商银行存入1,000元。
     ```

- 在initMessageSource中得方法主要功能是提取配置中定义的messageSource，并将其记录在Spring的容器中，也就是 AbstractApplicationContext中。如果用户未设置资源文件的话，Spring也提供了默认的配置 DelegatingMessageSource。

- 在initMessageSource中获取自定义资源文件的方式beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class)，在这里Spring使用了硬编码的方式硬性规定了自定义资源文件必须为messageSource，否则便会获取不到自定义资源配置，这也是为什么之前提供Bean的id如果不为messageSource会抛出异常。

```Java
//AbstractApplicationContext
protected void initMessageSource() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
      	//如果在配置中已经配置了messageSource，那么将messageSource提取并记录在this.messageSource中
        this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
        // Make MessageSource aware of parent MessageSource.
        if (this.parent != null && this.messageSource instanceof HierarchicalMessageSource) {
            HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
            if (hms.getParentMessageSource() == null) {
                // Only set parent context as parent MessageSource if no parent MessageSource
                // registered already.
                hms.setParentMessageSource(getInternalParentMessageSource());
            }
        }
        if (logger.isDebugEnabled()) {
            logger.debug("Using MessageSource [" + this.messageSource + "]");
        }
    }
    else {
        // Use empty MessageSource to be able to accept getMessage calls.
      	//如果用户并没有定义配置文件，那么使用临时的DelegatingMessageSource以便于作为调用getMessage方法的返回。
        DelegatingMessageSource dms = new DelegatingMessageSource();
        dms.setParentMessageSource(getInternalParentMessageSource());
        this.messageSource = dms;
        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
        if (logger.isDebugEnabled()) {
            logger.debug("Unable to locate MessageSource with name '" + MESSAGE_SOURCE_BEAN_NAME +
                    "': using default [" + this.messageSource + "]");
        }
    }
}
```

- 通过读取并将自定义资源文件配置记录在容器中，那么就可以在获取资源文件的时候直接使用了。在 AbstractApplicationContext中的获取资源文件属性的方法：

```Java
@Override
public String getMessage(String code, Object args[], String defaultMessage, Locale locale) {
    return getMessageSource().getMessage(code, args, defaultMessage, locale);
}
```

##### 初始化ApplicationEventMulticaster

- 讲解Spring的时候传播器之前，先了解一下Spring的事件监听的简单用法。

1. 定义监听事件。

   ```Java
   public class TestEvent extends ApplicationEvent {

       public String msg;

       public TestEvent(Object source) {
           super(source);
       }

       public TestEvent(Object source, String msg) {
           super(source);
           this.msg = msg;
       }

       public void print() {
           System.out.println(msg);
       }
   }
   ```

2. 定义监听器。

   ```Java
   public class TestListener implements ApplicationListener {
       @Override
       public void onApplicationEvent(ApplicationEvent event) {
           if (event instanceof TestEvent) {
               TestEvent testEvent = (TestEvent) event;
               testEvent.print();
           }
       }
   }
   ```

3. 添加配置文件。

   ```XML
   <bean id="testListener" class="com.listener.TestListener"/>
   ```

4. 测试。

   ```Java
   public class Test {

       public static void main(String[] args) {
           ApplicationContext context = new ClassPathXmlApplicationContext("classpath:com/listener/applicationContext.xml");

           TestEvent event = new TestEvent("hello", "msg");
           context.publishEvent(event);
       }
   }
   ```

- 当程序运行时，Spring会将发出的TestEvent事件转给我们自定义的TestListener进行进一步处理。
- 这是一个典型的观察者模式，可以在比较关心的时间结束后及时处理。下面看看 ApplicationEventMulticaster是如何被初始化的，以确保功能的正确运行。
- initApplicationEventMulticaster的方式比较简单，无非考虑两种情况：
  - 如果用户自定义了事件广播器，那么使用用户自定义的事件广播器。
  - 如果用户没有自定义事件广播器，那么使用默认的 ApplicationEventMulticaster。

```Java
protected void initApplicationEventMulticaster() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
        this.applicationEventMulticaster =
                beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
        if (logger.isDebugEnabled()) {
            logger.debug("Using ApplicationEventMulticaster [" + this.applicationEventMulticaster + "]");
        }
    }
    else {
        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
        if (logger.isDebugEnabled()) {
            logger.debug("Unable to locate ApplicationEventMulticaster with name '" +
                    APPLICATION_EVENT_MULTICASTER_BEAN_NAME +
                    "': using default [" + this.applicationEventMulticaster + "]");
        }
    }
}
```

- 按照之前介绍的顺序及逻辑，可以推断，作为广播器，一定是用于存放监听器并在适合的时候调用监听器，我们可以进入默认的广播器实现 SimpleApplicationEventMulticaster看。

```Java
@Override
public void multicastEvent(ApplicationEvent event) {
    multicastEvent(event, resolveDefaultEventType(event));
}

@Override
public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {
    ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {
        Executor executor = getTaskExecutor();
        if (executor != null) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    invokeListener(listener, event);
                }
            });
        }
        else {
            invokeListener(listener, event);
        }
    }
}
```

- 可以推断，当产生Spring事件的时候会默认使用 SimpleApplicationEventMulticaster的 MulticastEvent来广播事件，遍历所有监听器，并使用监听器中的onApplicationEvent方法来 进行监听器的处理。
- 对于每个监听器来说其实都可以获取到产生的事件，但是是否进行处理则由时间监听器来决定。

##### 注册监听器

- Spring注册监听器的时候做的逻辑操作：

```Java
	protected void registerListeners() {
		// Register statically specified listeners first.
      	//硬编码方式注册的监听器处理
		for (ApplicationListener<?> listener : getApplicationListeners()) {
			getApplicationEventMulticaster().addApplicationListener(listener);
		}

		// Do not initialize FactoryBeans here: We need to leave all regular beans
		// uninitialized to let post-processors apply to them!
      	//配置文件注册的监听器处理
		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
		for (String listenerBeanName : listenerBeanNames) {
			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
		}

		// Publish early application events now that we finally have a multicaster...
		Set<ApplicationEvent> earlyEventsToProcess = this.earlyApplicationEvents;
		this.earlyApplicationEvents = null;
		if (earlyEventsToProcess != null) {
			for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
				getApplicationEventMulticaster().multicastEvent(earlyEvent);
			}
		}
	}
```

### 初始化非延迟加载单例

- 完成BeanFactory的初始化工作，其中包括 ConversionService的配置、配置冻结以及非延迟加载的bean的初始化工作。

```Java
protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // Initialize conversion service for this context.
    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &&
            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
        beanFactory.setConversionService(
                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    }

    // Register a default embedded value resolver if no bean post-processor
    // (such as a PropertyPlaceholderConfigurer bean) registered any before:
    // at this point, primarily for resolution in annotation attribute values.
    if (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver(new StringValueResolver() {
            @Override
            public String resolveStringValue(String strVal) {
                return getEnvironment().resolvePlaceholders(strVal);
            }
        });
    }

    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    for (String weaverAwareName : weaverAwareNames) {
        getBean(weaverAwareName);
    }

    // Stop using the temporary ClassLoader for type matching.
    beanFactory.setTempClassLoader(null);

    // Allow for caching all bean definition metadata, not expecting further changes.
  	//冻结所有的bean定义，说明注册的bean定义将不被修改或任何进一步的处理。
    beanFactory.freezeConfiguration();

    // Instantiate all remaining (non-lazy-init) singletons.
  	//初始化剩下的单实例（非惰性的）
    beanFactory.preInstantiateSingletons();
}
```

1.  ConversionService的设置

   - 之前提到过使用自定义类型转换器从String转换为Date的方式，在Spring中还提供了另一种转换方式：使用Converter。

   1. 定义转换器。

      ```Java
      public class String2DateConverter implements Converter<String, Date> {
          @Override
          public Date convert(String source) {
              SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
              try {
                  return sdf.parse(source);
              } catch (ParseException e) {
                  return null;
              }
          }
      }
      ```

   2. 注册。

      ```XML
      <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">
          <property name="converters">
              <list>
                  <bean class="com.converter.String2DateConverter"/>
              </list>
          </property>
      </bean>
      ```

   3. 测试。

      - 这样就可以使用Converter为我们提供的功能了，下面通过一个简便的方法来对比直接测试。

      ```Java
      public static void main(String[] args) {
          DefaultConversionService conversionService = new DefaultConversionService();
          conversionService.addConverter(new String2DateConverter());
          String dateStr = "2010-01-01 00:00:00";
          Date date = conversionService.convert(dateStr, Date.class);
          System.out.println(date);
      }
      ```

   - 通过以上的功能我们看到了Converter以及 ConversionService提供的便利功能，其中的配置就是在当前函数中被初始化的。

2. 冻结配置

   - 冻结所有的bean定义，说明注册的bean定义将不被修改或者进行任何进一步的处理。

   ```Java
   //DefaultListableBeanFactory
   @Override
   public void freezeConfiguration() {
       this.configurationFrozen = true;
       this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);
   }
   ```

3. 初始化非延迟加载

   - ApplicationContext实现的默认行为就是在启动时将所有单例bean提前进行实例化。
   - 提前实例化意味着作为初始化过程的一部分，ApplicationContext实例会创建并配置所有的单例bean。
   - 这个实例化的过程就是在finishBeanFactoryInitialization中完成的。

   ```Java
   //DefaultListableBeanFactory
   @Override
   public void preInstantiateSingletons() throws BeansException {
       if (this.logger.isDebugEnabled()) {
           this.logger.debug("Pre-instantiating singletons in " + this);
       }

       // Iterate over a copy to allow for init methods which in turn register new bean definitions.
       // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
       List<String> beanNames = new ArrayList<String>(this.beanDefinitionNames);

       // Trigger initialization of all non-lazy singleton beans...
       for (String beanName : beanNames) {
           RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
           if (!bd.isAbstract() && bd.isSingleton() && !bd.isLazyInit()) {
               if (isFactoryBean(beanName)) {
                   final FactoryBean<?> factory = (FactoryBean<?>) getBean(FACTORY_BEAN_PREFIX + beanName);
                   boolean isEagerInit;
                   if (System.getSecurityManager() != null && factory instanceof SmartFactoryBean) {
                       isEagerInit = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {
                           @Override
                           public Boolean run() {
                               return ((SmartFactoryBean<?>) factory).isEagerInit();
                           }
                       }, getAccessControlContext());
                   }
                   else {
                       isEagerInit = (factory instanceof SmartFactoryBean &&
                               ((SmartFactoryBean<?>) factory).isEagerInit());
                   }
                   if (isEagerInit) {
                       getBean(beanName);
                   }
               }
               else {
                   getBean(beanName);
               }
           }
       }

       // Trigger post-initialization callback for all applicable beans...
       for (String beanName : beanNames) {
           Object singletonInstance = getSingleton(beanName);
           if (singletonInstance instanceof SmartInitializingSingleton) {
               final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
               if (System.getSecurityManager() != null) {
                   AccessController.doPrivileged(new PrivilegedAction<Object>() {
                       @Override
                       public Object run() {
                           smartSingleton.afterSingletonsInstantiated();
                           return null;
                       }
                   }, getAccessControlContext());
               }
               else {
                   smartSingleton.afterSingletonsInstantiated();
               }
           }
       }
   }
   ```

### finishRefresh

- 在Spring中还提供了 Lifecycle接口，Lifecycle中包含start/stop方法，实现此接口后Spring会保证在启动的时候调用其start方法开始生命周期，并在Spring关闭的时候调用stop方法来结束生命周期，通常用来配置后台程序，在启动后一直运行（如对MQ进行轮询等）。
- 而ApplicationContext的初始化最后正是保证了这一功能的实现。

```Java
//AbstractApplicationContext
protected void finishRefresh() {
    // Initialize lifecycle processor for this context.
    initLifecycleProcessor();

    // Propagate refresh to lifecycle processor first.
    getLifecycleProcessor().onRefresh();

    // Publish the final event.
    publishEvent(new ContextRefreshedEvent(this));

    // Participate in LiveBeansView MBean, if active.
    LiveBeansView.registerApplicationContext(this);
}
```

1. initLifecycleProcessor

   - 当ApplicationContext启动或停止时，它会通过LifecycleProcessor来与所有声明的bean的周期做状态更新，而在 LifecycleProcessor的使用前首先需要初始化。

   ```Java
   //AbstractApplicationContext
   protected void initLifecycleProcessor() {
       ConfigurableListableBeanFactory beanFactory = getBeanFactory();
       if (beanFactory.containsLocalBean(LIFECYCLE_PROCESSOR_BEAN_NAME)) {
           this.lifecycleProcessor =
                   beanFactory.getBean(LIFECYCLE_PROCESSOR_BEAN_NAME, LifecycleProcessor.class);
           if (logger.isDebugEnabled()) {
               logger.debug("Using LifecycleProcessor [" + this.lifecycleProcessor + "]");
           }
       }
       else {
           DefaultLifecycleProcessor defaultProcessor = new DefaultLifecycleProcessor();
           defaultProcessor.setBeanFactory(beanFactory);
           this.lifecycleProcessor = defaultProcessor;
           beanFactory.registerSingleton(LIFECYCLE_PROCESSOR_BEAN_NAME, this.lifecycleProcessor);
           if (logger.isDebugEnabled()) {
               logger.debug("Unable to locate LifecycleProcessor with name '" +
                       LIFECYCLE_PROCESSOR_BEAN_NAME +
                       "': using default [" + this.lifecycleProcessor + "]");
           }
       }
   }
   ```

2. onRefresh

   - 启动所有实现了Lifecycle接口的bean。

   ```Java
   //DefaultLifecycleProcessor
   @Override
   public void onRefresh() {
       startBeans(true);
       this.running = true;
   }

   private void startBeans(boolean autoStartupOnly) {
       Map<String, Lifecycle> lifecycleBeans = getLifecycleBeans();
       Map<Integer, LifecycleGroup> phases = new HashMap<Integer, LifecycleGroup>();
       for (Map.Entry<String, ? extends Lifecycle> entry : lifecycleBeans.entrySet()) {
           Lifecycle bean = entry.getValue();
           if (!autoStartupOnly || (bean instanceof SmartLifecycle && ((SmartLifecycle) bean).isAutoStartup())) {
               int phase = getPhase(bean);
               LifecycleGroup group = phases.get(phase);
               if (group == null) {
                   group = new LifecycleGroup(phase, this.timeoutPerShutdownPhase, lifecycleBeans, autoStartupOnly);
                   phases.put(phase, group);
               }
               group.add(entry.getKey(), bean);
           }
       }
       if (!phases.isEmpty()) {
           List<Integer> keys = new ArrayList<Integer>(phases.keySet());
           Collections.sort(keys);
           for (Integer key : keys) {
               phases.get(key).start();
           }
       }
   }
   ```

3. publishEvent

   - 当完成ApplicationContext初始化的时候，要通过Spring中的事件发布机制来发出 ContextRefreshEvent事件，以保证对应的监听器可以做进一步的逻辑处理。

   ```Java
   //AbstractApplicationContext
   @Override
   public void publishEvent(ApplicationEvent event) {
       publishEvent(event, null);
   }

   protected void publishEvent(Object event, ResolvableType eventType) {
       Assert.notNull(event, "Event must not be null");
       if (logger.isTraceEnabled()) {
           logger.trace("Publishing event in " + getDisplayName() + ": " + event);
       }

       // Decorate event as an ApplicationEvent if necessary
       ApplicationEvent applicationEvent;
       if (event instanceof ApplicationEvent) {
           applicationEvent = (ApplicationEvent) event;
       }
       else {
           applicationEvent = new PayloadApplicationEvent<Object>(this, event);
           if (eventType == null) {
               eventType = ((PayloadApplicationEvent)applicationEvent).getResolvableType();
           }
       }

       // Multicast right now if possible - or lazily once the multicaster is initialized
       if (this.earlyApplicationEvents != null) {
           this.earlyApplicationEvents.add(applicationEvent);
       }
       else {
           getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
       }

       // Publish event via parent context as well...
       if (this.parent != null) {
           if (this.parent instanceof AbstractApplicationContext) {
               ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
           }
           else {
               this.parent.publishEvent(event);
           }
       }
   }
   ```

   ​