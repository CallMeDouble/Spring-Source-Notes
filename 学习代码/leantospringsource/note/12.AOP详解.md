# AOP

- 使用面向对象编程（OOP）有一些弊端，当需要为多个不具有继承关系的对象引入同一个公共行为时，例如日志、安全监测时，我们只有在每个对象里引用公共行为，这样程序中就产生大量的重复代码，程序就不便于维护了。
- 所以就有了一个对面向对象编程的补充，即面向方面编程（AOP），AOP所关注的方向是横向的，不同于OOP的纵向。
- Spring中提供了AOP的实现，但是在低版本Spring中定义一个切面是比较麻烦的，需要实现特定接口，并进行一些较为复杂的配置，低版本Spring AOP的配置是被批评最多的地方。
- 在Spring2.0中，Spring AOP可以使用@ AspectJ注解非常容易地定义一个切面，不需要实现任何的接口。
- Spring2.0采用@AspectJ注解对POJO进行标注，从而定义一个包含切点信息和增强横切逻辑的切面。Spring2.0可以将这个切面织入到匹配的目标Bean中。
- @AspectJ注解使用AspectJ切点表达式语法进行切点定义，可以通过切点函数、运算符、通配符等高级功能进行切点定义，拥有强大的连接描述能力。

---

### 动态 AOP使用实例

1. 创建用于拦截的bean。

   - 在实际工作中，此bean可能是满足业务需要的核心逻辑，例如test方法中可能会封装着某个核心业务，如果需要在test前后加入日志来跟踪调试，直接修改源码并不符合面向对象的设计方法，接下的Spring帮我们做到这一点。

   ```Java
   public class TestBean {

       private String testStr = "testStr";

       public String getTestStr() {
           return testStr;
       }

       public void setTestStr(String testStr) {
           this.testStr = testStr;
       }

       public void test() {
           System.out.println("test");
       }
   }
   ```

2. 创建Advisor。

   - Spring中摒弃了最原始的繁杂配置方式而采用@AspectJ注解对POJO进行标注，使AOP的工作大大简化。

   ```Java
   @Aspect
   public class AspectJTest {

       @Pointcut("execution(* *.test(..))")
       public void test() {

       }

       @Before("test()")
       public void beforeTest() {
           System.out.println("beforeTest");
       }

       @After("test()")
       public void afterTest() {
           System.out.println("afterTest");
       }

       @Around("test()")
       public Object arountTest(ProceedingJoinPoint p) {
           System.out.println("before1");
           Object o = null;
           try {
               o = p.proceed();
           } catch (Throwable throwable) {
               throwable.printStackTrace();
           }
           System.out.println("after1");
           return o;
       }

       @AfterReturning("test()")
       public void returnTest() {
           System.out.println("return");
       }
   }
   ```

3. 创建配置文件。

   - 要在Spring中开启AOP功能，还需在配置文件中作如下声明：

   ```XML
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xmlns:aop="http://www.springframework.org/schema/aop"
          xsi:schemaLocation="http://www.springframework.org/schema/beans
                              http://www.springframework.org/schema/beans/spring-beans.xsd
                              http://www.springframework.org/schema/aop
                              http://www.springframework.org/schema/aop/spring-aop.xsd">

       <aop:aspectj-autoproxy/>

       <bean id="test" class="com.aop.TestBean"/>
       <bean class="com.aop.AspectJTest"/>

   </beans>
   ```

4. 测试。

   ```Java
   public static void main(String[] args) {
       ApplicationContext bf = new ClassPathXmlApplicationContext("classpath:com/aop/springaop.xml");
       TestBean bean = (TestBean) bf.getBean("test");
       bean.test();
   }
   ```

   ```Control
   before1
   beforeTest
   test
   after1
   afterTest
   return
   ```

---

### 动态AOP自定义标签

- Spring是否支持注解的AOP是由一个配置文件控制的，也就是`<aop:aspectj-autoproxy/>`，当在配置文件中声明了这配置的时候，Spring就会支持注解的AOP，那么我们分析就从句注解开始。
- 之前讲过Spring的自定义注解，如果声明了自定义的注解，那么就一定会在程序中的某个地方注册了对应的解析器。

```Java
//AopNamespaceHandler
public void init() {
    this.registerBeanDefinitionParser("config", new ConfigBeanDefinitionParser());
    this.registerBeanDefinitionParser("aspectj-autoproxy", new AspectJAutoProxyBeanDefinitionParser());
    this.registerBeanDefinitionDecorator("scoped-proxy", new ScopedProxyBeanDefinitionDecorator());
    this.registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
}
```

- 在解析配置文件的时候，一旦遇到 aspectj-autoproxy注解时就会使用解析器AspectJAutoProxyBeanDefinitionParser进行解析。

```Java
//AspectJAutoProxyBeanDefinitionParser
@Override
public BeanDefinition parse(Element element, ParserContext parserContext) {
  	//注册AnnotationAwareAspectJAutoProxyCreator
    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);
  	//对于注解中子类的处理
    extendBeanDefinition(element, parserContext);
    return null;
}
```

- 其中 registerAspectJAnnotationAutoProxyCreatorIfNecessary函数是我们比较关心的，也是关键逻辑的实现。

```Java
//AopNamespaceUtils
/**
 * 注册AnnotationAwareAspectJAutoProxyCreator
 * @param parserContext
 * @param sourceElement
 */
public static void registerAspectJAnnotationAutoProxyCreatorIfNecessary(
        ParserContext parserContext, Element sourceElement) {

  	//注册或升级AutoProxyCreator定义beanName为org.springframework.aop.config.internalAutoProxyCreator的BeanDefinition
    BeanDefinition beanDefinition = AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(
            parserContext.getRegistry(), parserContext.extractSource(sourceElement));
  
  	//对于proxy-target-class以及expose-proxy属性的处理
    useClassProxyingIfNecessary(parserContext.getRegistry(), sourceElement);
  
  	//注册组件并通知，便于监听器做进一步处理
    registerComponentIfNecessary(beanDefinition, parserContext);
}
```

- 在registerAspectJAnnotationAutoProxyCreatorIfNecessary方法中主要完成了3件事，基本每行代码就是一个完整的逻辑。

1. 注册或者升级AnnotationAwareAspectJAutoProxyCreator

   - 对于AOP的实现，基本上都是靠AnnotationAwareAspectJAutoProxyCreator去完成。
   - 它可以根据@Point的注解定义的切点来自动代理匹配的bean。但是为了配置简便，Spring使用了自定义配置来帮助我们自动注册 AnnotationAwareAspectJAutoProxyCreator，其注册过程就是在这里实现的。

   ```Java
   //AopConfigUtils
   public static BeanDefinition registerAspectJAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) {
       return registerOrEscalateApcAsRequired(AspectJAwareAdvisorAutoProxyCreator.class, registry, source);
   }

   private static BeanDefinition registerOrEscalateApcAsRequired(Class<?> cls, BeanDefinitionRegistry registry, Object source) {
       Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
     	//如果已经存在了自动代理创建器且存在的自动代理创建器与现在的不一致，那么需要根据优先级来判断到底需要使用哪个
       if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
           BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
           if (!cls.getName().equals(apcDefinition.getBeanClassName())) {
               int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
               int requiredPriority = findPriorityForClass(cls);
               if (currentPriority < requiredPriority) {
                 	//改变bean最重要的就是改变bean所对应的className属性
                   apcDefinition.setBeanClassName(cls.getName());
               }
           }
         	//如果已经存在自动代理创建器并且与将来要创建的一致，那么无需再此创建
           return null;
       }
       RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);
       beanDefinition.setSource(source);
       beanDefinition.getPropertyValues().add("order", Ordered.HIGHEST_PRECEDENCE);
       beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
       registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
       return beanDefinition;
   }
   ```

   - 以上代码中实现了自动注册AnnotationAwareAspectJAutoProxyCreator类的功能，同时这里还涉及了一个优先级的问题，如果已经存在了自动代理创建器，而且存在的自动代理创建器与现在的不一致，那么需要根据优先级来判断到底需要使用哪个。

2. 处理proxy-target-class以及expose-proxy属性

   - useClassProxyingIfNecessary实现了proxy-target-class属性以及expose-proxy属性的处理。

   ```Java
   //AopNamespaceUtils
   private static void useClassProxyingIfNecessary(BeanDefinitionRegistry registry, Element sourceElement) {
       if (sourceElement != null) {
         	//对于proxy-target-class属性的处理。
           boolean proxyTargetClass = Boolean.valueOf(sourceElement.getAttribute(PROXY_TARGET_CLASS_ATTRIBUTE));
           if (proxyTargetClass) {
               AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
           }
         	//对于expose-proxy属性的处理
           boolean exposeProxy = Boolean.valueOf(sourceElement.getAttribute(EXPOSE_PROXY_ATTRIBUTE));
           if (exposeProxy) {
               AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
           }
       }
   }

   //强制使用的过程其实也是一个属性设置的过程
   public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {
       if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
           BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
           definition.getPropertyValues().add("proxyTargetClass", Boolean.TRUE);
       }
   }

   public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {
       if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
           BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
           definition.getPropertyValues().add("exposeProxy", Boolean.TRUE);
       }
   }
   ```

   - proxy-target-class：Spring AOP部分使用JDK动态代理或者 CGLIB来为目标对象创建代理（建议尽量使用JDK的动态代理）。
   - 如果被代理的目标对象实现了至少一个接口，则会使用JDK动态代理。所有该目标类型实现的接口都将被代理。若该目标对象没有实现任何接口，则创建一个CGLIB代理。
   - 如果希望强制使用CGLIB代理，（例如希望代理目标对象的所有方法，而不只是实现自接口的方法）那也可以。但是需要考虑以下两个问题：
     - 无法通知（advise）Final方法，因为它们不能被覆写。
     - 你需要将CGLIB二进制发行包放在classpath下面。
   - 与之相较，JDK本身就提供了动态代理，强制使用CGLIB代理需要将<aop:config>的proxy-target-class属性设为true：

   ```XML
   <aop:config proxy-target-class="true">...</aop:config>
   ```

   - 当需要使用CGLIB代理和@AspectJ自动代理支持，可以按照以下方式设置`<aop:aspectj-autoproxy>`的proxy-target-class属性：

     - JDK动态代理：其代理对象必须是某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。
     - CGLIB代理：实现原理类类似于JDK动态代理，只是它在运行期间生成的代理对象是针对目标类扩展的子类，CGLIB是高效的代理生成包，底层是依靠ASM（开源的Java字节码编辑类库）操作字节码实现的，性能比JDK强。
     - expose-proxy：有时候目标对象内部的自我调用将无法实施切面中的增强，如下示例：

     ```Java
     public interface AService {
         public void a();
         public void b();
     }

     public class AServiceImpl1 implements AService {
         @Override
         @Transactional(propagation = Propagation.REQUIRED)
         public void a() {
             this.b();
         }

         @Override
         @Transactional(propagation = Propagation.REQUIRES_NEW)
         public void b() {
         }
     }
     ```

   - 此处的this指向目标对象，因此调用this.b()将不会执行b事务切面，即不会执行事务增强，因此b的方法的事务定义为“@Transactional(propagation = Propagation.REQUIRES_NEW)”将不会实施，为了解决这个问题，我们可以这样做：

   ```XML
   <aop:aspectj-autoproxy expose-proxy="true"/>
   ```

   - 然后将以上代码的“this.b();”修改为“((AService) AopContext.currentProxy()).b();”即可。
   - 通过以上修改便可以完成对a和b方法的同时增强。
   - 最后注册组件并通知，便于监听器做进一步处理。

---

### 创建AOP代理

- 自定义配置完成了对AnnotationAwareAspectJAutoProxyCreator类型的自动注册，这个类做了什么工作来完成AOP的操作呢？
- ![](img/14.png?raw=true)
- AnnotationAwareAspectJAutoProxyCreator实现了BeanPostProcesser接口，而实现了BeanPostProcesser后，当Spring加载这个Bean时会在实例化前调用其postProcessAfterInitialization方法，而我们对AOP逻辑的分析也由此开始。
- 在父类AbstractAutoProxyCreator的postProcessAfterInitialization中代码如下：

```Java
//AbstractAutoProxyCreator
@Override
public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
    if (bean != null) {
      	//根据给定的bean的class和name构建个key，格式：beanClassName_beanName
        Object cacheKey = getCacheKey(bean.getClass(), beanName);
        if (!this.earlyProxyReferences.contains(cacheKey)) {
          	//如果它适合被代理，则需要封装指定bean。
            return wrapIfNecessary(bean, beanName, cacheKey);
        }
    }
    return bean;
}

protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
  	//如果已经处理过
    if (beanName != null && this.targetSourcedBeans.contains(beanName)) {
        return bean;
    }
  	//无需增强
    if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) {
        return bean;
    }
  	//给定的bean类是否代表一个基础设施类，基础设施类不应代理，或者配置了指定bean不需要自动代理
    if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
        this.advisedBeans.put(cacheKey, Boolean.FALSE);
        return bean;
    }

    // Create proxy if we have advice.
  	//如果存在增强方法则创建代理
    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
  	//如果获取到了增强则需要针对增强创建代理
    if (specificInterceptors != DO_NOT_PROXY) {
        this.advisedBeans.put(cacheKey, Boolean.TRUE);
      	//创建代理
        Object proxy = createProxy(
                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
        this.proxyTypes.put(cacheKey, proxy.getClass());
        return proxy;
    }

    this.advisedBeans.put(cacheKey, Boolean.FALSE);
    return bean;
}
```

- 代理真正开始前需要经过一些判断，比如是否已经处理过或者是否需要跳过的bean，而真正创建代理的代码是从getAdvicesAndAdvisorsForBean开始的。
- 创建代理主要包含了两个步骤：
  1. 获取增强方法或者增强器。
  2. 根据获取的增强进行代理。
- 核心逻辑（AbstractAutoProxyCreator的postProcessAfterInitialization函数）的时序图如图：![](img/15.png?raw=true)
- 虽然看似简单，但是每个步骤中都经历了大量复杂的逻辑。首先看看获取增强方法的实现逻辑。

```Java
//AbstractAdvisorAutoProxyCreator
@Override
protected Object[] getAdvicesAndAdvisorsForBean(Class<?> beanClass, String beanName, TargetSource targetSource) {
    List<Advisor> advisors = findEligibleAdvisors(beanClass, beanName);
    if (advisors.isEmpty()) {
        return DO_NOT_PROXY;
    }
    return advisors.toArray();
}

protected List<Advisor> findEligibleAdvisors(Class<?> beanClass, String beanName) {
    List<Advisor> candidateAdvisors = findCandidateAdvisors();
    List<Advisor> eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
    extendAdvisors(eligibleAdvisors);
    if (!eligibleAdvisors.isEmpty()) {
        eligibleAdvisors = sortAdvisors(eligibleAdvisors);
    }
    return eligibleAdvisors;
}
```

- 对于指定bean的增强方法的获取一定是包含两个步骤的，获取所有的增强以及寻找所有增强中适用于bean的增强并应用。
- 其中`findCandidateAdvisors()`与`findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName)`便是做了这两件事情。
- 如果无法找到对应的增强器便返回DO_NOT_PROXY，其中DO_NOT_PROXY=null。

##### 获取增强器

- 由于我们分析的是使用注解进行的AOP，所有对于`findCandidateAdvisors()`的实现其实是由AnnotationAwareAspectJAutoProxyCreator类完成的。

```Java
//AnnotationAwareAspectJAutoProxyCreator
@Override
protected List<Advisor> findCandidateAdvisors() {
    // Add all the Spring advisors found according to superclass rules.
  	//当使用注解方式配置AOP的时候并不是丢弃了对XML配置的支持。
  	//在这里调用父类方法加载配置文件中的AOP声明
    List<Advisor> advisors = super.findCandidateAdvisors();
    // Build Advisors for all AspectJ aspects in the bean factory.
    advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());
    return advisors;
}
```

- AnnotationAwareAspectJAutoProxyCreator间接继承了AbstractAdvisorAutoProxyCreator，在实现获取增强的方法除了保留父类的获取配置文件中定义的增强外，同时添加了获取Bean的注解增强的功能，其实现正是由`this.aspectJAdvisorsBuilder.buildAspectJAdvisors()`来实现的。
- 该函数实现的大概步骤：
  1. 获取所有beanName，这一步骤中所有在beanFactory中注册的Bean都会被提取出来。
  2. 遍历所有beanName，并找出声明AspectJ注解的类，进行进一步的处理。
  3. 对标记为AspectJ注解的类进行增强器的提取。
  4. 将提取结果加入缓存。
- 接下来看一下函数实现，对Spring中所有的类进行分析，提取Advisor。

```Java
//BeanFactoryAspectJAdvisorsBuilder
public List<Advisor> buildAspectJAdvisors() {
    List<String> aspectNames = this.aspectBeanNames;

    if (aspectNames == null) {
        synchronized (this) {
            aspectNames = this.aspectBeanNames;
            if (aspectNames == null) {
                List<Advisor> advisors = new LinkedList<Advisor>();
                aspectNames = new LinkedList<String>();
              	//获取所有的beanName
                String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(
                        this.beanFactory, Object.class, true, false);
              	//循环所有的beanName找出对应的增强方法
                for (String beanName : beanNames) {
                  	//不合法的bean则略过，由子类定义规则，默认返回true
                    if (!isEligibleBean(beanName)) {
                        continue;
                    }
                    // We must be careful not to instantiate beans eagerly as in this case they
                    // would be cached by the Spring container but would not have been weaved.
                  	//获取对应的bean的类型
                    Class<?> beanType = this.beanFactory.getType(beanName);
                    if (beanType == null) {
                        continue;
                    }
                  	//如果存在AspectJ注解
                    if (this.advisorFactory.isAspect(beanType)) {
                        aspectNames.add(beanName);
                        AspectMetadata amd = new AspectMetadata(beanType, beanName);
                        if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {
                            MetadataAwareAspectInstanceFactory factory =
                                    new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);
                          	//解析标记AspectJ注解中增强的方法
                            List<Advisor> classAdvisors = this.advisorFactory.getAdvisors(factory);
                            if (this.beanFactory.isSingleton(beanName)) {
                                this.advisorsCache.put(beanName, classAdvisors);
                            }
                            else {
                                this.aspectFactoryCache.put(beanName, factory);
                            }
                            advisors.addAll(classAdvisors);
                        }
                        else {
                            // Per target or per this.
                            if (this.beanFactory.isSingleton(beanName)) {
                                throw new IllegalArgumentException("Bean with name '" + beanName +
                                        "' is a singleton, but aspect instantiation model is not singleton");
                            }
                            MetadataAwareAspectInstanceFactory factory =
                                    new PrototypeAspectInstanceFactory(this.beanFactory, beanName);
                            this.aspectFactoryCache.put(beanName, factory);
                            advisors.addAll(this.advisorFactory.getAdvisors(factory));
                        }
                    }
                }
                this.aspectBeanNames = aspectNames;
                return advisors;
            }
        }
    }

    if (aspectNames.isEmpty()) {
        return Collections.emptyList();
    }
  
  	//记录在缓存中
    List<Advisor> advisors = new LinkedList<Advisor>();
    for (String aspectName : aspectNames) {
        List<Advisor> cachedAdvisors = this.advisorsCache.get(aspectName);
        if (cachedAdvisors != null) {
            advisors.addAll(cachedAdvisors);
        }
        else {
            MetadataAwareAspectInstanceFactory factory = this.aspectFactoryCache.get(aspectName);
            advisors.addAll(this.advisorFactory.getAdvisors(factory));
        }
    }
    return advisors;
}
```

- 至此，我们已经完成了Advisor的提取，在上面的步骤中最为重要也是最为繁杂的就是增强器的获取。
- 而这一功能委托给了getAdvisors方法去实现（`this.advisorFactory.getAdvisors(factory)`）。

```Java
//ReflectiveAspectJAdvisorFactory
@Override
public List<Advisor> getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {
  	//获取标记为AspectJ的类
    Class<?> aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
  	//获取标记为AspectJ的name
    String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();
  	//验证
    validate(aspectClass);

    // We need to wrap the MetadataAwareAspectInstanceFactory with a decorator
    // so that it will only instantiate once.
    MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =
            new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);

    List<Advisor> advisors = new LinkedList<Advisor>();
    for (Method method : getAdvisorMethods(aspectClass)) {
        Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);
        if (advisor != null) {
            advisors.add(advisor);
        }
    }

    // If it's a per target aspect, emit the dummy instantiating aspect.
    if (!advisors.isEmpty() && lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
      	//如果寻找的增强器不为空而且又配置了增强延迟初始化那么需要在首位加入同步实例化增强器
        Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);
        advisors.add(0, instantiationAdvisor);
    }

    // Find introduction fields.
  	//获取DeclareParents注解
    for (Field field : aspectClass.getDeclaredFields()) {
        Advisor advisor = getDeclareParentsAdvisor(field);
        if (advisor != null) {
            advisors.add(advisor);
        }
    }

    return advisors;
}
```

- 函数中首先完成了对增强器的获取，包括获取注解以及根据注解生成增强的步骤。
- 然后考虑到在配置中可能会将增强配置成延迟初始化，那么需要在首位加入同步实例化增强器以保证增强使用之前的实例化。
- 最后是对DeclareParents注解的获取。

1. 普通增强器的获取。

   - 普通增强器的获取逻辑通过getAdvisor方法实现，实现步骤包括对切点的注解的获取以及根据注解信息生成增强。

   ```Java
   //ReflectiveAspectJAdvisorFactory
   @Override
   public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,
           int declarationOrderInAspect, String aspectName) {

       validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());
   	//切点信息的获取
       AspectJExpressionPointcut expressionPointcut = getPointcut(
               candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());
       if (expressionPointcut == null) {
           return null;
       }
   	//根据切点信息生成增强器
       return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,
               this, aspectInstanceFactory, declarationOrderInAspect, aspectName);
   }
   ```

   1. 切点信息的获取。

      - 所谓获取切点信息就是指注解的表达式信息的获取，如`@Before("test()")`。

      ```Java
      //ReflectiveAspectJAdvisorFactory
      private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class<?> candidateAspectClass) {
        	//获取方法上的注解
          AspectJAnnotation<?> aspectJAnnotation =
                  AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
          if (aspectJAnnotation == null) {
              return null;
          }

        	//使用AspectJExpressionPointcut实例封装获取的信息
          AspectJExpressionPointcut ajexp =
                  new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class<?>[0]);
        	//提取得到的注解中的表达式，如：
        	//@Pointcut("execution(* *.*test*(..))")中的execution(* *.*test*(..))
          ajexp.setExpression(aspectJAnnotation.getPointcutExpression());
          ajexp.setBeanFactory(this.beanFactory);
          return ajexp;
      }

      //AbstractAspectJAdvisorFactory
      @SuppressWarnings("unchecked")
      protected static AspectJAnnotation<?> findAspectJAnnotationOnMethod(Method method) {
        	//设置敏感的注解类
          Class<?>[] classesToLookFor = new Class<?>[] {
                  Before.class, Around.class, After.class, AfterReturning.class, AfterThrowing.class, Pointcut.class};
          for (Class<?> c : classesToLookFor) {
              AspectJAnnotation<?> foundAnnotation = findAnnotation(method, (Class<Annotation>) c);
              if (foundAnnotation != null) {
                  return foundAnnotation;
              }
          }
          return null;
      }

      //获取指定方法上的注解并使用AspectJAnnotation封装
      private static <A extends Annotation> AspectJAnnotation<A> findAnnotation(Method method, Class<A> toLookFor) {
          A result = AnnotationUtils.findAnnotation(method, toLookFor);
          if (result != null) {
              return new AspectJAnnotation<A>(result);
          }
          else {
              return null;
          }
      }
      ```

   2. 根据切点信息生成增强。

      - 所有的增强都由Advisor的实现类InstantiationModelAwarePointcutAdvisorImpl统一封装。

      ```Java
      //InstantiationModelAwarePointcutAdvisorImpl
      public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,
              Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,
              MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

        	//test()
          this.declaredPointcut = declaredPointcut;
        	//public void test.AspectJTest.beforeTest()
          this.declaringClass = aspectJAdviceMethod.getDeclaringClass();
          this.methodName = aspectJAdviceMethod.getName();
          this.parameterTypes = aspectJAdviceMethod.getParameterTypes();
          this.aspectJAdviceMethod = aspectJAdviceMethod;

          this.aspectJAdvisorFactory = aspectJAdvisorFactory;
        
          this.aspectInstanceFactory = aspectInstanceFactory;
        	//0
          this.declarationOrder = declarationOrder;
        	//test.AspectJTest
          this.aspectName = aspectName;

          if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {
              // Static part of the pointcut is a lazy type.
              Pointcut preInstantiationPointcut = Pointcuts.union(
                      aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);

              // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.
              // If it's not a dynamic pointcut, it may be optimized out
              // by the Spring AOP infrastructure after the first evaluation.
              this.pointcut = new PerTargetInstantiationModelPointcut(
                      this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);
              this.lazy = true;
          }
          else {
              // A singleton aspect.
              this.pointcut = this.declaredPointcut;
              this.lazy = false;
              this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);
          }
      }
      ```

      - 在封装过程中只是简单地将信息封装在类的实例中，所有的信息单纯地赋值，在实例初始化的过程还完成了对于增强器的初始化。
      - 因为不同的增强所体现的逻辑是不同的，比如@Before("test()")与@After("test()") 标签的不同就是增强器增强的位置不同，所以就需要不同的增强器来完成不同的逻辑，而根据注解中的信息初始化对应的增强器就是在instantiateAdvice函数中实现的。

      ```Java
      //InstantiationModelAwarePointcutAdvisorImpl
      private Advice instantiateAdvice(AspectJExpressionPointcut pcut) {
          return this.aspectJAdvisorFactory.getAdvice(this.aspectJAdviceMethod, pcut,
                  this.aspectInstanceFactory, this.declarationOrder, this.aspectName);
      }

      //ReflectiveAspectJAdvisorFactory
      @Override
      public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,
              MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {

          Class<?> candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();
          validate(candidateAspectClass);

          AspectJAnnotation<?> aspectJAnnotation =
                  AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);
          if (aspectJAnnotation == null) {
              return null;
          }

          // If we get here, we know we have an AspectJ method.
          // Check that it's an AspectJ-annotated class
          if (!isAspect(candidateAspectClass)) {
              throw new AopConfigException("Advice must be declared inside an aspect type: " +
                      "Offending method '" + candidateAdviceMethod + "' in class [" +
                      candidateAspectClass.getName() + "]");
          }

          if (logger.isDebugEnabled()) {
              logger.debug("Found AspectJ method: " + candidateAdviceMethod);
          }

          AbstractAspectJAdvice springAdvice;
        	//根据不同的注解类型封装不同的增强器
          switch (aspectJAnnotation.getAnnotationType()) {
              case AtBefore:
                  springAdvice = new AspectJMethodBeforeAdvice(
                          candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                  break;
              case AtAfter:
                  springAdvice = new AspectJAfterAdvice(
                          candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                  break;
              case AtAfterReturning:
                  springAdvice = new AspectJAfterReturningAdvice(
                          candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                  AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();
                  if (StringUtils.hasText(afterReturningAnnotation.returning())) {
                      springAdvice.setReturningName(afterReturningAnnotation.returning());
                  }
                  break;
              case AtAfterThrowing:
                  springAdvice = new AspectJAfterThrowingAdvice(
                          candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                  AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();
                  if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {
                      springAdvice.setThrowingName(afterThrowingAnnotation.throwing());
                  }
                  break;
              case AtAround:
                  springAdvice = new AspectJAroundAdvice(
                          candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);
                  break;
              case AtPointcut:
                  if (logger.isDebugEnabled()) {
                      logger.debug("Processing pointcut '" + candidateAdviceMethod.getName() + "'");
                  }
                  return null;
              default:
                  throw new UnsupportedOperationException(
                          "Unsupported advice type on method: " + candidateAdviceMethod);
          }

          // Now to configure the advice...
          springAdvice.setAspectName(aspectName);
          springAdvice.setDeclarationOrder(declarationOrder);
          String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);
          if (argNames != null) {
              springAdvice.setArgumentNamesFromStringArray(argNames);
          }
          springAdvice.calculateArgumentBindings();
          return springAdvice;
      }
      ```

      - 从函数中可以看到，Spring会根据不同的注解生成不同的增强器。

      - 例如AtBefore会对应AspectJMethodBeforeAdvice，而在AspectJMethodBeforeAdvice中完成了增强方法的逻辑。

      - 尝试分析一下几个常用的增强器实现。

        - MethodBeforeAdviceInterceptor.

          ```Java
          public class MethodBeforeAdviceInterceptor implements MethodInterceptor, Serializable {

          	private MethodBeforeAdvice advice;
          ```


          	/**
          	 * Create a new MethodBeforeAdviceInterceptor for the given advice.
          	 * @param advice the MethodBeforeAdvice to wrap
          	 */
          	public MethodBeforeAdviceInterceptor(MethodBeforeAdvice advice) {
          		Assert.notNull(advice, "Advice must not be null");
          		this.advice = advice;
          	}
    
          	@Override
          	public Object invoke(MethodInvocation mi) throws Throwable {
          		this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis() );
          		return mi.proceed();
          	}
    
          }
          ```
    
          - 其中属性MethodBeforeAdvice代表着前置增强的AspectJMethodBeforeAdvice，跟踪before方法：
    
          ```Java
          //AspectJMethodBeforeAdvice
          @Override
          public void before(Method method, Object[] args, Object target) throws Throwable {
              invokeAdviceMethod(getJoinPointMatch(), null, null);
          }
    
          //AbstractAspectJAdvice
          protected Object invokeAdviceMethod(JoinPointMatch jpMatch, Object returnValue, Throwable ex) throws Throwable {
              return invokeAdviceMethodWithGivenArgs(argBinding(getJoinPoint(), jpMatch, returnValue, ex));
          }
    
          //AbstractAspectJAdvice
          protected Object invokeAdviceMethodWithGivenArgs(Object[] args) throws Throwable {
              Object[] actualArgs = args;
              if (this.aspectJAdviceMethod.getParameterTypes().length == 0) {
                  actualArgs = null;
              }
              try {
                  ReflectionUtils.makeAccessible(this.aspectJAdviceMethod);
                  // TODO AopUtils.invokeJoinpointUsingReflection
                	//激活增强方法
                  return this.aspectJAdviceMethod.invoke(this.aspectInstanceFactory.getAspectInstance(), actualArgs);
              }
              catch (IllegalArgumentException ex) {
                  throw new AopInvocationException("Mismatch on arguments to advice method [" +
                          this.aspectJAdviceMethod + "]; pointcut expression [" +
                          this.pointcut.getPointcutExpression() + "]", ex);
              }
              catch (InvocationTargetException ex) {
                  throw ex.getTargetException();
              }
          }
          ```
    
          - invokeAdviceMethodWithGivenArgs方法中的aspectJAdviceMethod正是对于前置增强的方法，在这里实现了调用。
    
        - AspectJAfterAdvice。
    
          - 后置增强与前置增强有稍许不一致的地方。
          - 之前讲过的前置增强，大致的结构是在拦截器链中放置MethodBeforeAdviceInterceptor，而在MethodBeforeAdviceInterceptor中又放置了AspectJMethodBeforeAdvice，并在调用invoke时首先串联调用。但是在后置增强的时候却不一样，没有提供中间的类，而是直接在拦截器链中使用了中间的AspectJAfterAdvice。
    
          ```Java
          public class AspectJAfterAdvice extends AbstractAspectJAdvice
          		implements MethodInterceptor, AfterAdvice, Serializable {
    
          	public AspectJAfterAdvice(
          			Method aspectJBeforeAdviceMethod, AspectJExpressionPointcut pointcut, AspectInstanceFactory aif) {
    
          		super(aspectJBeforeAdviceMethod, pointcut, aif);
          	}


          	@Override
          	public Object invoke(MethodInvocation mi) throws Throwable {
          		try {
          			return mi.proceed();
          		}
          		finally {
          			//激活增强方法
          			invokeAdviceMethod(getJoinPointMatch(), null, null);
          		}
          	}
    
          	@Override
          	public boolean isBeforeAdvice() {
          		return false;
          	}
    
          	@Override
          	public boolean isAfterAdvice() {
          		return true;
          	}
    
          }
          ```

2. 增加同步实例化增强器

   - 如果寻找的增强器不为空而且又配置了增强延迟初始化，那么就需要在首位加入同步实例化增强器。同步实例化增强器SyntheticInstantiationAdvisor如下：

   ```Java
   //ReflectiveAspectJAdvisorFactory
   protected static class SyntheticInstantiationAdvisor extends DefaultPointcutAdvisor {

       public SyntheticInstantiationAdvisor(final MetadataAwareAspectInstanceFactory aif) {
           super(aif.getAspectMetadata().getPerClausePointcut(), new MethodBeforeAdvice() {
               @Override
             	//目标方法前调用，类似@Before
               public void before(Method method, Object[] args, Object target) {
                   // Simply instantiate the aspect
                   aif.getAspectInstance();
               }
           });
       }
   }
   ```

3. 获取DeclareParents注解

   - DeclareParents主要用于引介增强的注解形式的实现，而其实现方式与普通增强很类似，只不过使用DeclareParentsAdvisor对功能进行封装。

   ```Java
   //ReflectiveAspectJAdvisorFactory
   private Advisor getDeclareParentsAdvisor(Field introductionField) {
       DeclareParents declareParents = introductionField.getAnnotation(DeclareParents.class);
       if (declareParents == null) {
           // Not an introduction field
           return null;
       }

       if (DeclareParents.class == declareParents.defaultImpl()) {
           throw new IllegalStateException("'defaultImpl' attribute must be set on DeclareParents");
       }

       return new DeclareParentsAdvisor(
               introductionField.getType(), declareParents.value(), declareParents.defaultImpl());
   }
   ```

##### 寻找匹配的增强器

- 前面的函数已经完成了所有增强器的解析，但是对于所有增强器来讲，并不一定都适用于当前的Bean，还要挑出适合的增强器，也就是满足我们配置的通配符的增强器。
- 具体实现在`findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName)`中：

```Java
//AbstractAdvisorAutoProxyCreator
protected List<Advisor> findAdvisorsThatCanApply(
        List<Advisor> candidateAdvisors, Class<?> beanClass, String beanName) {

    ProxyCreationContext.setCurrentProxiedBeanName(beanName);
    try {
      	//过滤已经得到的advisors
        return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
    }
    finally {
        ProxyCreationContext.setCurrentProxiedBeanName(null);
    }
}
```

- 继续看`findAdvisorsThatCanApply(candidateAdvisors, beanClass)`:

```Java
//AopUtils
public static List<Advisor> findAdvisorsThatCanApply(List<Advisor> candidateAdvisors, Class<?> clazz) {
    if (candidateAdvisors.isEmpty()) {
        return candidateAdvisors;
    }
    List<Advisor> eligibleAdvisors = new LinkedList<Advisor>();
  	//首先处理引介增强
    for (Advisor candidate : candidateAdvisors) {
        if (candidate instanceof IntroductionAdvisor && canApply(candidate, clazz)) {
            eligibleAdvisors.add(candidate);
        }
    }
    boolean hasIntroductions = !eligibleAdvisors.isEmpty();
    for (Advisor candidate : candidateAdvisors) {
      	//引介已经处理
        if (candidate instanceof IntroductionAdvisor) {
            // already processed
            continue;
        }
      	//对于普通bean的处理
        if (canApply(candidate, clazz, hasIntroductions)) {
            eligibleAdvisors.add(candidate);
        }
    }
    return eligibleAdvisors;
}
```

- 该函数的主要功能是寻找所有增强器中适用于当前class的增强器。
- 引介增强 与普通的增强器是处理不一样的，所以分开处理。
- 而对于真正的匹配在canApply中实现。

```Java
//AopUtils
public static boolean canApply(Advisor advisor, Class<?> targetClass) {
    return canApply(advisor, targetClass, false);
}

public static boolean canApply(Advisor advisor, Class<?> targetClass, boolean hasIntroductions) {
    if (advisor instanceof IntroductionAdvisor) {
        return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
    }
    else if (advisor instanceof PointcutAdvisor) {
        PointcutAdvisor pca = (PointcutAdvisor) advisor;
        return canApply(pca.getPointcut(), targetClass, hasIntroductions);
    }
    else {
        // It doesn't have a pointcut so we assume it applies.
        return true;
    }
}

public static boolean canApply(Pointcut pc, Class<?> targetClass, boolean hasIntroductions) {
    Assert.notNull(pc, "Pointcut must not be null");
    if (!pc.getClassFilter().matches(targetClass)) {
        return false;
    }

    MethodMatcher methodMatcher = pc.getMethodMatcher();
    if (methodMatcher == MethodMatcher.TRUE) {
        // No need to iterate the methods if we're matching any method anyway...
        return true;
    }

    IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
    if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
        introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
    }

    Set<Class<?>> classes = new LinkedHashSet<Class<?>>(ClassUtils.getAllInterfacesForClassAsSet(targetClass));
    classes.add(targetClass);
    for (Class<?> clazz : classes) {
        Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);
        for (Method method : methods) {
            if ((introductionAwareMethodMatcher != null &&
                    introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||
                    methodMatcher.matches(method, targetClass)) {
                return true;
            }
        }
    }

    return false;
}
```

##### 创建代理

- 在获取所有对应bean的增强器后，便可以进行代理的创建了。

```Java
//AbstractAutoProxyCreator
protected Object createProxy(
        Class<?> beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) {

    if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
        AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
    }

    ProxyFactory proxyFactory = new ProxyFactory();
  	//获取当前类中的相关属性
    proxyFactory.copyFrom(this);
	//决定对于给定的bean是否应该使用targetClass而不是他的接口代理，
  	//检查proxyTargetClass设置以及preserveTargetClass属性
    if (!proxyFactory.isProxyTargetClass()) {
        if (shouldProxyTargetClass(beanClass, beanName)) {
            proxyFactory.setProxyTargetClass(true);
        }
        else {
            evaluateProxyInterfaces(beanClass, proxyFactory);
        }
    }

    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    for (Advisor advisor : advisors) {
      	//加入增强器
        proxyFactory.addAdvisor(advisor);
    }
	//设置要代理的类
    proxyFactory.setTargetSource(targetSource);
  	//定制代理
    customizeProxyFactory(proxyFactory);
	//用来控制代理工厂被配置之后，是否还允许修改通知。
  	//缺省值为false（即在代理被配置之后，不允许修改代理的配置）。
    proxyFactory.setFrozen(this.freezeProxy);
    if (advisorsPreFiltered()) {
        proxyFactory.setPreFiltered(true);
    }

    return proxyFactory.getProxy(getProxyClassLoader());
}
```

- 对于代理类的创建及处理，Spring委托给了ProxyFactory去处理，而在此函数中主要是对ProxyFactory的初始化操作，进而对真正的创建代理做准备，这里初始化操作包括如下内容。
  1. 获取当前类中属性。
  2. 添加代理接口。
  3. 封装Advisor并加入到ProxyFactory中。
  4. 设置要代理的类。
  5. 当然在Spring中还为子类提供了定制的函数customizeProxyFactory，子类可以在此函数中进行对ProxyFactory的进一步封装。
  6. 进行获取代理操作。
- 其中，封装Advisor并加入到ProxyFactory中以及创建代理是两个相对繁琐的过程，可以通过ProxyFactory提供的addAdvisor方法直接将增强器置入代理创建工厂中，但是将拦截器封装为增强器还是需要一定的逻辑的。

```Java
//AbstractAutoProxyCreator
protected Advisor[] buildAdvisors(String beanName, Object[] specificInterceptors) {
    // Handle prototypes correctly...
  	//解析注册的所有interceptorName
    Advisor[] commonInterceptors = resolveInterceptorNames();

    List<Object> allInterceptors = new ArrayList<Object>();
    if (specificInterceptors != null) {
      	//加入拦截器
        allInterceptors.addAll(Arrays.asList(specificInterceptors));
        if (commonInterceptors.length > 0) {
            if (this.applyCommonInterceptorsFirst) {
                allInterceptors.addAll(0, Arrays.asList(commonInterceptors));
            }
            else {
                allInterceptors.addAll(Arrays.asList(commonInterceptors));
            }
        }
    }
    if (logger.isDebugEnabled()) {
        int nrOfCommonInterceptors = commonInterceptors.length;
        int nrOfSpecificInterceptors = (specificInterceptors != null ? specificInterceptors.length : 0);
        logger.debug("Creating implicit proxy for bean '" + beanName + "' with " + nrOfCommonInterceptors +
                " common interceptors and " + nrOfSpecificInterceptors + " specific interceptors");
    }

    Advisor[] advisors = new Advisor[allInterceptors.size()];
    for (int i = 0; i < allInterceptors.size(); i++) {
      	//拦截器进行封装转化为Advisor
        advisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i));
    }
    return advisors;
}

//DefaultAdvisorAdapterRegistry
@Override
public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException {
  	//如果要封装对象本身就是Advisor类型的那么无需再做过多处理
    if (adviceObject instanceof Advisor) {
        return (Advisor) adviceObject;
    }
  	//因为此封装方法只对Advisor与Advice两种类型的数据有效，如果不是将不能封装
    if (!(adviceObject instanceof Advice)) {
        throw new UnknownAdviceTypeException(adviceObject);
    }
    Advice advice = (Advice) adviceObject;
    if (advice instanceof MethodInterceptor) {
        // So well-known it doesn't even need an adapter.
      	//如果是MethodInterceptor类型则使用DefaultPointcutAdvisor封装
        return new DefaultPointcutAdvisor(advice);
    }
  	//如果存在Advisor的适配器那么也同样需要进行封装
    for (AdvisorAdapter adapter : this.adapters) {
        // Check that it is supported.
        if (adapter.supportsAdvice(advice)) {
            return new DefaultPointcutAdvisor(advice);
        }
    }
    throw new UnknownAdviceTypeException(advice);
}
```

- 由于Spring中涉及过多的拦截器、增强器、增强方法等方式来对逻辑进行增强，所有非常有必要统一封装成Advisor来进行代理的创建，完成了增强的封装过程，那么解析最重要的一步就是代理的创建与获取了。

```Java
//ProxyFactory
public Object getProxy(ClassLoader classLoader) {
    return createAopProxy().getProxy(classLoader);
}
```

1. 创建代理

   ```Java
   //ProxyCreatorSupport
   protected final synchronized AopProxy createAopProxy() {
       if (!this.active) {
           activate();
       }
       return getAopProxyFactory().createAopProxy(this);
   }

   //DefaultAopProxyFactory
   @Override
   public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
       if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
           Class<?> targetClass = config.getTargetClass();
           if (targetClass == null) {
               throw new AopConfigException("TargetSource cannot determine target class: " +
                       "Either an interface or a target is required for proxy creation.");
           }
           if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
               return new JdkDynamicAopProxy(config);
           }
           return new ObjenesisCglibAopProxy(config);
       }
       else {
           return new JdkDynamicAopProxy(config);
       }
   }
   ```

   - 到此已经完成代理的创建。
   - Spring是如何选择JDKProxy和CglibProxy的实现呢？
   - 从if的判断条件可以看到3个方面影响着Spring的判断。
     - optimize：用来控制通过CGLIB创建的代理是否使用激进的优化策略，除非完全了解AOP代理如果处理优化，否则不推荐用户使用这个设置。目前这个属性仅用于CGLIB代理，对于JDK动态代理（缺省代理）无效。
     - proxyTargetClass：这个属性为true时，目标类本身被代理而不是目标类的接口。如果这个属性被设为true，CGLIB代理将被创建，设置方式：`<aop:aspectj-autoproxy proxy-target-class="true"/>`。
     - hasNoUserSuppliedProxyInterfaces：是否存在代理接口。
   - 下面是对JDK与Cglib方式的总结。
     - 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。
     - 如果目标对象实现了接口，可以强制使用CGLIB实现AOP。
     - 如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换。
   - 如何强制使用CGLIB实现AOP？
     1. 添加CGLIB库，Spring_HOME/cglib/*.jar。
     2. 在Spring配置文件中加入`<aop:aspectj-autoproxy proxy-target-class="true"/>`。
   - JDK动态的代理和CGLIB字节码生成的区别？
     - JDK动态代理只能对实现了接口的类生成代理，而不能针对类。
     - CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所有该类或方法最好不要声明成final。

2. 获取代理

   1. JDK代理使用示例。

      - 创建业务接口，业务对外提供的接口，包含着业务可以对外提供的功能。

      ```Java
      public interface UserService {

          /**
           * 目标方法
           */
          public abstract void add();
      }
      ```

      - 创建业务接口实现类。

      ```Java
      public class UserServiceImpl implements UserService {

          /** (non-Javadoc)
           *  @see com.aop3.UserService#add()
           */
          @Override
          public void add() {
              System.out.println("------------add-------------");
          }
      }
      ```

      - 创建自定义的InvocationHandler，用于对接口提供的方法进行增强。

      ```Java
      public class MyInvocationHandler implements InvocationHandler {

          //目标对象
          private Object target;

          /**
           * 构造方法
           * @param target 目标对象
           */
          public MyInvocationHandler(Object target) {
              super();
              this.target = target;
          }

          /**
           * 执行目标对象的方法
           */
          @Override
          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

              //在目标对象的方法执行之前简单的打印一下
              System.out.println("------------before-------------");

              //执行目标对象的方法
              Object result = method.invoke(target, args);

              //在目标对象的方法执行之后简单的打印一下
              System.out.println("------------after-------------");

              return result;
          }

          /**
           * 获取目标对象的代理对象
           * @return 代理对象
           */
          public Object getProxy() {
              return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),
                      target.getClass().getInterfaces(), this);
          }
      }
      ```

      - 最后进行测试，验证对于接口的增强是否起到作用。

      ```Java
      public class ProxyTest {

          @Test
          public void testProxy() {
              //实例化目标对象
              UserService userService = new UserServiceImpl();

              //实例化InvocationHandler
              MyInvocationHandler invocationHandler = new MyInvocationHandler(userService);

              //根据目标对象生成代理对象
              UserService proxy = (UserService) invocationHandler.getProxy();

              //调用代理对象方法
              proxy.add();
          }
      }
      ```

      - 执行结果如下：

      ```Control
      ------------before-------------
      ------------add-------------
      ------------after-------------
      ```

      - Spring AOP实现其实也是用了Proxy和InvocationHandler这两个东西的。
      - 回顾一下使用JDK代理的方式，在整个创建过程中，对于InvocationHandler的创建最为核心的，在自定义的InvocationHandler中需要重写3个函数。
        - 构造函数，将代理的对象传入。
        - invoke方法，此方法中实现了AOP增强的所有逻辑。
        - getProxy方法，此方法千篇一律，但是必不可少。
      - 看看Spring中的JDK代理实现是不是也是这样做，继续之前的跟踪，到达`JdkDynamicAopProxy#getProxy(ClassLoader classLoader)`。

      ```Java
      //JdkDynamicAopProxy
      @Override
      public Object getProxy() {
          return getProxy(ClassUtils.getDefaultClassLoader());
      }

      @Override
      public Object getProxy(ClassLoader classLoader) {
          if (logger.isDebugEnabled()) {
              logger.debug("Creating JDK dynamic proxy: target source is " + this.advised.getTargetSource());
          }
          Class<?>[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
          findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
          return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
      }
      ```

      - JDKProxy使用的关键是创建自定义的Invocationhandler，而Invocationhandler中包含了需要覆盖的函数getProxy，而当前的方法正是完成了这个操作。
      - JdkDynamicAopProxy也确实实现了InvocationHandler接口，那么可以推断出JdkDynamicAopProxy会有个invoke函数，其中包括了AOP的核心逻辑。

      ```Java
      //JdkDynamicAopProxy
      @Override
      public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
          MethodInvocation invocation;
          Object oldProxy = null;
          boolean setProxyContext = false;

          TargetSource targetSource = this.advised.targetSource;
          Class<?> targetClass = null;
          Object target = null;

          try {
            	//equals方法的处理
              if (!this.equalsDefined && AopUtils.isEqualsMethod(method)) {
                  // The target does not implement the equals(Object) method itself.
                  return equals(args[0]);
              }
            	//hash方法的处理
              else if (!this.hashCodeDefined && AopUtils.isHashCodeMethod(method)) {
                  // The target does not implement the hashCode() method itself.
                  return hashCode();
              }
              else if (method.getDeclaringClass() == DecoratingProxy.class) {
                  // There is only getDecoratedClass() declared -> dispatch to proxy config.
                  return AopProxyUtils.ultimateTargetClass(this.advised);
              }
            	/**
            	 * Class类的isAssignableFrom(Class cls)方法：
            	 * 如果调用这个方法的class或接口与参数cls表示的类或接口相同，
            	 * 或者是参数cls表示的类或接口的父类，则返回true。
            	 * 形象的地：自身类.class.isAssignedableFrom(自身类或子类.class) 返回true
            	 * 例：
            	 * System.out.println(ArrayList.class.isAssignableFrom(Object.class));
            	 * //false
            	 * System.out.println(Object.class.isAssignableFrom(ArrayList.class));
            	 * //true
            	 */
              else if (!this.advised.opaque && method.getDeclaringClass().isInterface() &&
                      method.getDeclaringClass().isAssignableFrom(Advised.class)) {
                  // Service invocations on ProxyConfig with the proxy config...
                  return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
              }

              Object retVal;
      		//有时候目标对象内部的自我调用将无法实施切面的增强则需要通过此属性暴露代理
              if (this.advised.exposeProxy) {
                  // Make invocation available if necessary.
                  oldProxy = AopContext.setCurrentProxy(proxy);
                  setProxyContext = true;
              }

              // May be null. Get as late as possible to minimize the time we "own" the target,
              // in case it comes from a pool.
              target = targetSource.getTarget();
              if (target != null) {
                  targetClass = target.getClass();
              }

              // Get the interception chain for this method.
            	//获取当前方法的拦截链
              List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

              // Check whether we have any advice. If we don't, we can fallback on direct
              // reflective invocation of the target, and avoid creating a MethodInvocation.
              if (chain.isEmpty()) {
                  // We can skip creating a MethodInvocation: just invoke the target directly
                  // Note that the final invoker must be an InvokerInterceptor so we know it does
                  // nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
                	//如果没有发现任何拦截器那么直接调用切点方法
                  Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                  retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
              }
              else {
                  // We need to create a method invocation...
                	//将拦截器封装在ReflectiveMethodInvocation，
                	//以便于使用其proceed进行链接表用拦截器
                  invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
                  // Proceed to the joinpoint through the interceptor chain.
                	//执行拦截器链
                  retVal = invocation.proceed();
              }

              // Massage return value if necessary.
            	//返回结果
              Class<?> returnType = method.getReturnType();
              if (retVal != null && retVal == target &&
                      returnType != Object.class && returnType.isInstance(proxy) &&
                      !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
                  // Special case: it returned "this" and the return type of the method
                  // is type-compatible. Note that we can't help if the target sets
                  // a reference to itself in another returned object.
                  retVal = proxy;
              }
              else if (retVal == null && returnType != Void.TYPE && returnType.isPrimitive()) {
                  throw new AopInvocationException(
                          "Null return value from advice does not match primitive return type for: " + method);
              }
              return retVal;
          }
          finally {
              if (target != null && !targetSource.isStatic()) {
                  // Must have come from TargetSource.
                  targetSource.releaseTarget(target);
              }
              if (setProxyContext) {
                  // Restore old proxy.
                  AopContext.setCurrentProxy(oldProxy);
              }
          }
      }
      ```

      - 上面的函数中最主要的工作就是创建了一个拦截器链，并使用ReflectiveMethodInvocation类进行了链的封装，而在ReflectiveMethodInvocation类的proceed方法中实现了拦截器的逐一调用。
      - 在proceed方法中是怎么实现前置增强在目标方法前调用后置增强在目标方法后调用的逻辑的呢？

      ```Java
      //ReflectiveMethodInvocation
      @Override
      public Object proceed() throws Throwable {
          //	We start with an index of -1 and increment early.
        	//执行完所有增强后执行切点方法
          if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
              return invokeJoinpoint();
          }

        	//获取下一个要执行的拦截器
          Object interceptorOrInterceptionAdvice =
                  this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
          if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
              // Evaluate dynamic method matcher here: static part will already have
              // been evaluated and found to match.
            	//动态匹配
              InterceptorAndDynamicMethodMatcher dm =
                      (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
              if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) {
                  return dm.interceptor.invoke(this);
              }
              else {
                  // Dynamic matching failed.
                  // Skip this interceptor and invoke the next in the chain.
                	//不匹配则不执行拦截器
                  return proceed();
              }
          }
          else {
              // It's an interceptor, so we just invoke it: The pointcut will have
              // been evaluated statically before this object was constructed.
            	/**
            	 * 普通拦截器，直接调用拦截器，比如：
            	 * ExposeInvocationInterceptor、
            	 * DelegatePerTargetObjectIntroductionInterceptor、
            	 * MethodBeforeAdviceInterceptor
            	 * AspectJAroundAdvice、
            	 * AspectJAfterAdvice
            	 */
            	//将this作为参数传递以保证当前实例中调用链的执行
              return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
          }
      }
      ```

      - 在proceed方法中，或许代码逻辑并没有我们想象得那么复杂，ReflectiveMethodInvocation中的主要职责是维护了链接调用的计数器，记录着当前调用链接的位置，以便链可以有序地进行下去。
      - 因此维护各种增强器的顺序委托给了各个增强器，使各个增强器在内部进行逻辑实现。

   2. CGLIB使用实例。

      - CGLIB是一个强大的高性能的代码生成包，它广泛地被许多AOP的框架使用，例如Spring AOP和dynaop，为它们提供方法的Interception（拦截）。
      - 最流行的ORM框架Hibernate也使用CGLIB来代理单端single-ended（多对一和一对一）关联（对集合的延迟抓取是采用其他机制实现的）。
      - EasyMock和jMock是通过使用模仿（moke）对象来测试Java代码的包。它们都通过使用CGLIB来为那些没有接口的类创建模仿（moke）对象。
      - CGLIB包的底层通过使用一个小而快的字节码处理框架ASM，来转换字节码并生成新的类。
      - 除了CGLIB包，脚本语言例如Groovy和BeanShell，也是使用ASM来生成Java的字节码。
      - 要直接使用ASM，要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉。
      - 下面快速了解CGLIB的使用实例：

      ```Java
      public class MethodInterceptorImpl implements MethodInterceptor{

          @Override
          public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
              System.err.println("Before invoke " + method);
              Object result = methodProxy.invokeSuper(o, objects);
              System.err.println("After invoke " + method);
              return result;
          }
      }

      public class EnhancerDemo {

          public static void main(String[] args) {
              Enhancer enhancer = new Enhancer();
              enhancer.setSuperclass(EnhancerDemo.class);
              enhancer.setCallback(new MethodInterceptorImpl());

              EnhancerDemo demo = (EnhancerDemo) enhancer.create();
              demo.test();
              System.out.println(demo);
          }

          public void test() {
              System.out.println("EnhancerDemo test()");
          }
      }
      ```

      ```Control
      Before invoke public void com.cglib.EnhancerDemo.test()
      EnhancerDemo test()
      After invoke public void com.cglib.EnhancerDemo.test()
      Before invoke public java.lang.String java.lang.Object.toString()
      Before invoke public native int java.lang.Object.hashCode()
      After invoke public native int java.lang.Object.hashCode()
      After invoke public java.lang.String java.lang.Object.toString()
      com.cglib.EnhancerDemo$$EnhancerByCGLIB$$b26881b6@32a1bec0
      ```

      - 可以看到`System.out.println(demo)`，demo首先调用了toString()方法，然后又调用了hashCode，生成对象为`com.cglib.EnhancerDemo$$EnhancerByCGLIB$$b26881b6@32a1bec0`的实例，这个类是运行时由CGLIB产生的。
      - 完成CGLIB代理的类是委托给Cglib2AopProxy类去实现的。
      - Cglib2AopProxy的入口应该在getProxy，也就是说在Cglib2AopProxy类的getProxy方法中实现了Enhancer的创建及接口封装。

      ```Java
      //CglibAopProxy
      @Override
      public Object getProxy() {
          return getProxy(null);
      }

      @Override
      public Object getProxy(ClassLoader classLoader) {
          if (logger.isDebugEnabled()) {
              logger.debug("Creating CGLIB proxy: target source is " + this.advised.getTargetSource());
          }

          try {
              Class<?> rootClass = this.advised.getTargetClass();
              Assert.state(rootClass != null, "Target class must be available for creating a CGLIB proxy");

              Class<?> proxySuperClass = rootClass;
              if (ClassUtils.isCglibProxyClass(rootClass)) {
                  proxySuperClass = rootClass.getSuperclass();
                  Class<?>[] additionalInterfaces = rootClass.getInterfaces();
                  for (Class<?> additionalInterface : additionalInterfaces) {
                      this.advised.addInterface(additionalInterface);
                  }
              }

              // Validate the class, writing log messages as necessary.
            	//验证Class
              validateClassIfNecessary(proxySuperClass, classLoader);

              // Configure CGLIB Enhancer...
            	//创建及配置Enhancer
              Enhancer enhancer = createEnhancer();
              if (classLoader != null) {
                  enhancer.setClassLoader(classLoader);
                  if (classLoader instanceof SmartClassLoader &&
                          ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
                      enhancer.setUseCache(false);
                  }
              }
              enhancer.setSuperclass(proxySuperClass);
              enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
              enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
              enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));

            	//设置拦截器
              Callback[] callbacks = getCallbacks(rootClass);
              Class<?>[] types = new Class<?>[callbacks.length];
              for (int x = 0; x < types.length; x++) {
                  types[x] = callbacks[x].getClass();
              }
              // fixedInterceptorMap only populated at this point, after getCallbacks call above
              enhancer.setCallbackFilter(new ProxyCallbackFilter(
                      this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
              enhancer.setCallbackTypes(types);

              // Generate the proxy class and create a proxy instance.
            	//生成代理类以及创建代理
              return createProxyClassAndInstance(enhancer, callbacks);
          }
          catch (CodeGenerationException ex) {
              throw new AopConfigException("Could not generate CGLIB subclass of class [" +
                      this.advised.getTargetClass() + "]: " +
                      "Common causes of this problem include using a final class or a non-visible class",
                      ex);
          }
          catch (IllegalArgumentException ex) {
              throw new AopConfigException("Could not generate CGLIB subclass of class [" +
                      this.advised.getTargetClass() + "]: " +
                      "Common causes of this problem include using a final class or a non-visible class",
                      ex);
          }
          catch (Throwable ex) {
              // TargetSource.getTarget() failed
              throw new AopConfigException("Unexpected AOP exception", ex);
          }
      }

      protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) {
          enhancer.setInterceptDuringConstruction(false);
          enhancer.setCallbacks(callbacks);
          return (this.constructorArgs != null ?
                  enhancer.create(this.constructorArgTypes, this.constructorArgs) :
                  enhancer.create());
      }
      ```

      - 以上函数完成的阐述了一个创建Spring中的Enhancer的过程，可以参考Enhancer的文档查看每个步骤的含义，这里最重要的是通过getCallbacks方法设置拦截器链。

      ```Java
      //CglibAopProxy
      private Callback[] getCallbacks(Class<?> rootClass) throws Exception {
          // Parameters used for optimization choices...
        	//对于expose-proxy属性的处理
          boolean exposeProxy = this.advised.isExposeProxy();
          boolean isFrozen = this.advised.isFrozen();
          boolean isStatic = this.advised.getTargetSource().isStatic();

          // Choose an "aop" interceptor (used for AOP calls).
        	//将拦截器封装在DynamicAdvisedInterceptor里
          Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised);

          // Choose a "straight to target" interceptor. (used for calls that are
          // unadvised but can return this). May be required to expose the proxy.
          Callback targetInterceptor;
          if (exposeProxy) {
              targetInterceptor = isStatic ?
                      new StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) :
                      new DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource());
          }
          else {
              targetInterceptor = isStatic ?
                      new StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) :
                      new DynamicUnadvisedInterceptor(this.advised.getTargetSource());
          }

          // Choose a "direct to target" dispatcher (used for
          // unadvised calls to static targets that cannot return this).
          Callback targetDispatcher = isStatic ?
                  new StaticDispatcher(this.advised.getTargetSource().getTarget()) : new SerializableNoOp();

          Callback[] mainCallbacks = new Callback[] {
            		//将拦截器链加入Callback中
                  aopInterceptor,  // for normal advice
                  targetInterceptor,  // invoke target without considering advice, if optimized
                  new SerializableNoOp(),  // no override for methods mapped to this
                  targetDispatcher, this.advisedDispatcher,
                  new EqualsInterceptor(this.advised),
                  new HashCodeInterceptor(this.advised)
          };

          Callback[] callbacks;

          // If the target is a static one and the advice chain is frozen,
          // then we can make some optimizations by sending the AOP calls
          // direct to the target using the fixed chain for that method.
          if (isStatic && isFrozen) {
              Method[] methods = rootClass.getMethods();
              Callback[] fixedCallbacks = new Callback[methods.length];
              this.fixedInterceptorMap = new HashMap<String, Integer>(methods.length);

              // TODO: small memory optimization here (can skip creation for methods with no advice)
              for (int x = 0; x < methods.length; x++) {
                  List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);
                  fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(
                          chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());
                  this.fixedInterceptorMap.put(methods[x].toString(), x);
              }

              // Now copy both the callbacks from mainCallbacks
              // and fixedCallbacks into the callbacks array.
              callbacks = new Callback[mainCallbacks.length + fixedCallbacks.length];
              System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length);
              System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length);
              this.fixedInterceptorOffset = mainCallbacks.length;
          }
          else {
              callbacks = mainCallbacks;
          }
          return callbacks;
      }
      ```

      - 在getCallback中Spring考虑了很多种情况，但是对于我们来说只需要理解最常用的就可以了。
      - 比如将advised属性封装在DynamicAdvisedInterceptor并加入在callbacks中。
      - 在前面的实例中，我们了解了CGLIB中对于方法的拦截器是通过将自定义的拦截器（实现MethodInterceptor接口）加入Callback中并在调用代理时直接激活拦截器中的Intercept方法实现的。
      - 那么在getCallback中正是实现了这样一个目的，DynamicAdvisedInterceptor继承自MethodInterceptor，加入Callback中后，在再次调用代理时会直接调用DynamicAdvisedInterceptor中的Intercept方法。
      - 由此推断，对于CGLIB方式实现的代理，其核心逻辑必然在DynamicAdvisedInterceptor中的Intercept中。

      ```Java
      //CglibAopProxy.DynamicAdvisedInterceptor
      @Override
      public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
          Object oldProxy = null;
          boolean setProxyContext = false;
          Class<?> targetClass = null;
          Object target = null;
          try {
              if (this.advised.exposeProxy) {
                  // Make invocation available if necessary.
                  oldProxy = AopContext.setCurrentProxy(proxy);
                  setProxyContext = true;
              }
              // May be null. Get as late as possible to minimize the time we
              // "own" the target, in case it comes from a pool...
              target = getTarget();
              if (target != null) {
                  targetClass = target.getClass();
              }
            	//获取拦截器链
              List<Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
              Object retVal;
              // Check whether we only have one InvokerInterceptor: that is,
              // no real advice, but just reflective invocation of the target.
              if (chain.isEmpty() && Modifier.isPublic(method.getModifiers())) {
                  // We can skip creating a MethodInvocation: just invoke the target directly.
                  // Note that the final invoker must be an InvokerInterceptor, so we know
                  // it does nothing but a reflective operation on the target, and no hot
                  // swapping or fancy proxying.
                	//如果拦截器链为空则直接激活原方法
                  Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
                  retVal = methodProxy.invoke(target, argsToUse);
              }
              else {
                  // We need to create a method invocation...
                	//进入链
                  retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
              }
              retVal = processReturnType(proxy, target, method, retVal);
              return retVal;
          }
          finally {
              if (target != null) {
                  releaseTarget(target);
              }
              if (setProxyContext) {
                  // Restore old proxy.
                  AopContext.setCurrentProxy(oldProxy);
              }
          }
      }
      ```

      - 上述的实现与JDK方式实现代理中的invoke方法大同小异，都是首先构造链，然后封装此链进行串联调用，稍有些区别就是在JDK中直接构造ReflectiveMethodInvocation，而在cglib中使用CglibMethodInvocation。
      - CglibMethodInvocation继承自ReflectiveMethodInvocation，但是proceed方法并没有重写。