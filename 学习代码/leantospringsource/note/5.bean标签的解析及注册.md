# 默认标签的解析

- 默认标签是在`parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate)`函数中进行的。
- 分别对4中不同的标签（import、alias、bean和beans）做了不同的处理。

```Java
private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
  	//对import标签的处理
	if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
		importBeanDefinitionResource(ele);
	}
  	//对alias标签的处理
	else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
		processAliasRegistration(ele);
	}
  	//对bean标签的处理
	else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
		processBeanDefinition(ele, delegate);
	}
  	//对beans标签的处理
	else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
		// recurse
		doRegisterBeanDefinitions(ele);
	}
}
```

---

# bean标签的解析及注册

- 在四种标签的解析中，对bean便签的解析最为复杂也最为重要。
- 首先进入`processBeanDefinition(ele, delegate)`函数。

```Java
protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
	if (bdHolder != null) {
		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
		try {
			// Register the final decorated instance.
			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
		}
		catch (BeanDefinitionStoreException ex) {
			getReaderContext().error("Failed to register bean definition with name '" +
					bdHolder.getBeanName() + "'", ele, ex);
		}
		// Send registration event.
		getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
	}
}
```

1. 首先委托BeanDefinitionDelegate类的`parseBeanDefinitionElement(ele)`方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder。经过这个方法后，bdHolder实例已经包含我们配置文件中配置的各种属性（如class、name、id、alias之类的属性）。
2. 当返回的bdHolder不为空的情况下若存在默认标签的子节点下再有自定义属性，还需要再次对自定义标签进行解析。
3. 解析完成后，需要对解析后的bdHolder进行注册，同样，注册操作委托给了BeanDefinitionReaderUtils的`registerBeanDefinition(bdHolder, getReaderContext().getRegistry())`方法。
4. 最后发出响应时间，通知相关的监听器，这个bean已经加载完成了。

- 时序图：![](img/7.png?raw=true)


---

### 解析BeanDefinition

- 元素解析及信息提取：`BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele)`

```Java
	//BeanDefinitionParserDelegate
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
		return parseBeanDefinitionElement(ele, null);
	}

	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) {
		//解析id属性
		String id = ele.getAttribute(ID_ATTRIBUTE);
		//解析name属性
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);

		//分割name属性
		List<String> aliases = new ArrayList<String>();
		if (StringUtils.hasLength(nameAttr)) {
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			aliases.addAll(Arrays.asList(nameArr));
		}

		String beanName = id;
		if (!StringUtils.hasText(beanName) && !aliases.isEmpty()) {
			beanName = aliases.remove(0);
			if (logger.isDebugEnabled()) {
				logger.debug("No XML 'id' specified - using '" + beanName +
						"' as bean name and " + aliases + " as aliases");
			}
		}

		if (containingBean == null) {
			checkNameUniqueness(beanName, aliases, ele);
		}

		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
		if (beanDefinition != null) {
			if (!StringUtils.hasText(beanName)) {
				try {
					//如果不存在beanName，那么根据Spring中提供的命名格则为当前bean生成对应的beanName
					if (containingBean != null) {
						beanName = BeanDefinitionReaderUtils.generateBeanName(
								beanDefinition, this.readerContext.getRegistry(), true);
					}
					else {
						beanName = this.readerContext.generateBeanName(beanDefinition);
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
						String beanClassName = beanDefinition.getBeanClassName();
						if (beanClassName != null &&
								beanName.startsWith(beanClassName) && beanName.length() > beanClassName.length() &&
								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
							aliases.add(beanClassName);
						}
					}
					if (logger.isDebugEnabled()) {
						logger.debug("Neither XML 'id' nor 'name' specified - " +
								"using generated bean name [" + beanName + "]");
					}
				}
				catch (Exception ex) {
					error(ex.getMessage(), ele);
					return null;
				}
			}
			String[] aliasesArray = StringUtils.toStringArray(aliases);
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
		}

		return null;
	}
```

- 该层主要工作：

> 1. 提取元素中的id以及name属性。
> 2. 进一步解析其他所有属性并统一封装至GenericBeanDefinition类型的实例中。
> 3. 如果检测到bean没有指定beanName，那么使用默认规则为此Bean生成beanName。
> 4. 将获取到的信息封装到BeanDefinitionHolder的实例中。

- 步骤2的解析过程：

```Java
	public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, BeanDefinition containingBean) {

		this.parseState.push(new BeanEntry(beanName));

		String className = null;
		//解析class属性
		if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
		}

		try {
			String parent = null;
			//解析parent属性
			if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
				parent = ele.getAttribute(PARENT_ATTRIBUTE);
			}
			//创建用于承载属性的AbstractBeanDefinition类型的GenericBeanDefinition
			AbstractBeanDefinition bd = createBeanDefinition(className, parent);

			//硬编码解析默认bean的各种属性
			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
 			//提取description
			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));

			//解析元数据
			parseMetaElements(ele, bd);
			//解析lookup-method属性
			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
			//解析replaced-method属性
			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

			//解析构造函数参数
			parseConstructorArgElements(ele, bd);
			//解析property子元素
			parsePropertyElements(ele, bd);
			//解析qualifier子元素
			parseQualifierElements(ele, bd);

			bd.setResource(this.readerContext.getResource());
			bd.setSource(extractSource(ele));

			return bd;
		}
		catch (ClassNotFoundException ex) {
			error("Bean class [" + className + "] not found", ele, ex);
		}
		catch (NoClassDefFoundError err) {
			error("Class that bean class [" + className + "] depends on not found", ele, err);
		}
		catch (Throwable ex) {
			error("Unexpected failure during bean definition parsing", ele, ex);
		}
		finally {
			this.parseState.pop();
		}

		return null;
	}
```

1. 创建用于属性承载的BeanDefinition

> - BeanDefinition是一个接口，在Spring中存在三种实现：RootBeanDefinition、ChildBeanDefinition和GenericBeanDefinition，三种实现都继承了AbstractBeanDefinition。
> - BeanDefinition是配置文件<bean>元素标签在容器中的内部表示形式。
> - <bean>元素标签拥有class、scope、lazy-init等配置属性，BeanDefinition则提供相应的beanClass、scope、lazyInit属性。
> - RootBeanDefinition是最常用的实现类，它对应一般的<bean>元素标签，GenericBeanDefinition是一站式服务类。
> - 父<bean>用RootBeanDefinition表示，子<bean>用ChildBeanDefinition表示，没有父<bean>的<bean>就使用RootBeanDefinition表示。
> - Spring通过BeanDefinition将配置文件中<bean>配置信息转换为容器的内部表示，并将这些BeanDefinition注册到BeanDefinitionRegistry中。
> - Spring容器的BeanDefinitionRegistry就像是Spring配置信息的内存数据库，主要是以map的形式保存，后续操作直接从BeanDefinitionRegistry中读取配置信息。
> - ![](img/8.png?raw=true)
>
> ```Java
> 	//BeanDefinitionParserDelegate
> 	protected AbstractBeanDefinition createBeanDefinition(String className, String parentName)
> 			throws ClassNotFoundException {
>
> 		return BeanDefinitionReaderUtils.createBeanDefinition(
> 				parentName, className, this.readerContext.getBeanClassLoader());
> 	}
>
> 	//BeanDefinitionReaderUtils
> 	public static AbstractBeanDefinition createBeanDefinition(
> 			String parentName, String className, ClassLoader classLoader) throws ClassNotFoundException {
>
> 		GenericBeanDefinition bd = new GenericBeanDefinition();
> 		//parentName可能为空
> 		bd.setParentName(parentName);
> 		if (className != null) {
> 			if (classLoader != null) {
> 				//如果classLoader不为空，则使用以传入的classLoader同一虚拟机加载类对象，否则只是记录className
> 				bd.setBeanClass(ClassUtils.forName(className, classLoader));
> 			}
> 			else {
> 				bd.setBeanClassName(className);
> 			}
> 		}
> 		return bd;
> 	}
> ```

2. 解析各种属性

> - 创建了bean信息的承载实例后，便可以进行bean信息的各种属性解析了。
> - `parseBeanDefinitionAttributes()`方法是对element所有元素属性进行解析：
>
> ```Java
> 	//BeanDefinitionParserDelegate
> 	public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
> 			BeanDefinition containingBean, AbstractBeanDefinition bd) {
>
> 		//singleton被升级为scope了
> 		if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
> 			error("Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration", ele);
> 		}
> 		//解析scope属性
> 		else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
> 			bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
> 		}
> 		else if (containingBean != null) {
> 			// Take default from containing bean in case of an inner bean definition.
> 			//在嵌入BeanDefinition情况下且没有单独制定scope属性则使用父类默认的属性
> 			bd.setScope(containingBean.getScope());
> 		}
>
> 		//解析abstract属性
> 		if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
> 			bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
> 		}
> 		//解析lazy-init属性
> 		String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
> 		if (DEFAULT_VALUE.equals(lazyInit)) {
> 			lazyInit = this.defaults.getLazyInit();
> 		}
> 		//若没有设置或设置成其他字符都会被设置为false
> 		bd.setLazyInit(TRUE_VALUE.equals(lazyInit));
>
> 		//解析autowire属性
> 		String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
> 		bd.setAutowireMode(getAutowireMode(autowire));
>
> 		//解析dependency-check属性
> 		String dependencyCheck = ele.getAttribute(DEPENDENCY_CHECK_ATTRIBUTE);
> 		bd.setDependencyCheck(getDependencyCheck(dependencyCheck));
>
> 		//解析depends-on属性
> 		if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
> 			String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
> 			bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
> 		}
>
> 		//解析autowire-candidate属性
> 		String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
> 		if ("".equals(autowireCandidate) || DEFAULT_VALUE.equals(autowireCandidate)) {
> 			String candidatePattern = this.defaults.getAutowireCandidates();
> 			if (candidatePattern != null) {
> 				String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);
> 				bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
> 			}
> 		}
> 		else {
> 			bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
> 		}
>
> 		//解析primary属性
> 		if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
> 			bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
> 		}
> 		//解析init-method属性
> 		if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
> 			String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);
> 			if (!"".equals(initMethodName)) {
> 				bd.setInitMethodName(initMethodName);
> 			}
> 		}
> 		else {
> 			if (this.defaults.getInitMethod() != null) {
> 				bd.setInitMethodName(this.defaults.getInitMethod());
> 				bd.setEnforceInitMethod(false);
> 			}
> 		}
> 		//解析destroy-method属性
> 		if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
> 			String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
> 			bd.setDestroyMethodName(destroyMethodName);
> 		}
> 		else {
> 			if (this.defaults.getDestroyMethod() != null) {
> 				bd.setDestroyMethodName(this.defaults.getDestroyMethod());
> 				bd.setEnforceDestroyMethod(false);
> 			}
> 		}
> 		//解析factory-method属性
> 		if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
> 			bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
> 		}
> 		//解析factory-bean属性
> 		if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
> 			bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
> 		}
>
> 		return bd;
> 	}
> ```

3. 解析子元素meta

> - meta属性的使用：
>
> ```XML
> <bean id="myTestBean" class="bean.MyTestBean">
> 	<meta key="testStr" value="aaaaaa"/>
> </bean>
> ```
>
> - 这段代码并不会体现在MyTestBean的属性中，而是一个额外的声明，当需要使用里面的信息的时候可以通过BeanDefinition的`getAttribute(key)`方法进行获取。
>
> ```Java
> 	//BeanDefinitionParserDelegate
> 	public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
> 		//获取当前节点的所有子元素
> 		NodeList nl = ele.getChildNodes();
> 		for (int i = 0; i < nl.getLength(); i++) {
> 			Node node = nl.item(i);
> 			//提取meta
> 			if (isCandidateElement(node) && nodeNameEquals(node, META_ELEMENT)) {
> 				Element metaElement = (Element) node;
> 				String key = metaElement.getAttribute(KEY_ATTRIBUTE);
> 				String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
> 				//使用key、value构造BeanMetadataAttribute
> 				BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
> 				attribute.setSource(extractSource(metaElement));
> 				//记录信息
> 				attributeAccessor.addMetadataAttribute(attribute);
> 			}
> 		}
> 	}
> ```

4. 解析子元素lookup-method

> - lookup-method被称为获取器注入。
>
> ```Java
> package test.lookup.bean;
>
> public class User {
>
>     public void showMe() {
>         System.out.println("i am user");
>     }
> }
>
> public class Teacher extends User {
>
>     @Override
>     public void showMe() {
>         System.out.println("i am Teacher");
>     }
> }
>
> public abstract class GetBeanTest {
>
>     public void showMe() {
>         this.getBean().showMe();
>     }
>
>     public abstract User getBean();
> }
>
> package test.lookup.bean;
>
> public class Main {
>
>     public static void main(String[] args) {
>         ApplicationContext bf = new ClassPathXmlApplicationContext("test/lookup/lookupTest.xml");
>         GetBeanTest test = (GetBeanTest) bf.getBean("getBeanTest");
>         test.showMe();
>     }
> }
> ```
>
> ```XML
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
>        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
>
>     <bean id="getBeanTest" class="test.lookup.bean.GetBeanTest">
>         <lookup-method name="getBean" bean="teacher"/>
>     </bean>
>     <bean id="teacher" class="test.lookup.bean.Teacher"/>
>
> </beans>
> ```
>
> ```控制台
> i am Teacher
> ```
>
> - 抽象方法还没被实现，但可以直接调用。
> - look-method子元素这个配置完成的功能是动态将teacher所代表的bean作为getBean的返回值。
> - 当我们业务变更或者在其他情况下，teacher里面的业务逻辑已经不再符合我们的业务要求，我们可以通过增加新的逻辑类，同时修改配置文件。
>
> ```Java
> package test.lookup.bean;
>
> public class User {
>
>     public void showMe() {
>         System.out.println("i am user");
>     }
> }
> ```
>
> ```XML
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
>        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
>
>     <bean id="getBeanTest" class="test.lookup.bean.GetBeanTest">
>         <lookup-method name="getBean" bean="student"/>
>     </bean>
>
>     <bean id="teacher" class="test.lookup.bean.Teacher"/>
>     <bean id="student" class="test.lookup.bean.Student"/>
>
>
> </beans>
> ```
>
> ```控制台
> i am student
> ```
>
> - lookup-method属性提取的源码`parseLookupOverrideSubElements(ele, bd.getMethodOverrides())`：
>
> ```Java
> 	public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
> 		NodeList nl = beanEle.getChildNodes();
> 		for (int i = 0; i < nl.getLength(); i++) {
> 			Node node = nl.item(i);
> 			//仅当在Spring默认bean的子元素下且为lookup-method时有效
> 			if (isCandidateElement(node) && nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {
> 				Element ele = (Element) node;
> 				//获取要修饰的方法
> 				String methodName = ele.getAttribute(NAME _ATTRIBUTE);
> 				//获取配置返回的bean
> 				String beanRef = ele.getAttribute(BEAN_ELEMENT);
> 				LookupOverride override = new LookupOverride(methodName, beanRef);
> 				override.setSource(extractSource(ele));
> 				overrides.addOverride(override);
> 			}
> 		}
> 	}
> ```
>
> - 该代码与parseMetaElements的代码大同小异。
> - 最大的区别在于if判断中的节点名称在这里被修改为LOOKUP_ELEMENT，在数据存储上通过使用LookupOverride类型的实体类来进行数据承载并记录在AbstractBeanDefinition中的methodOverrides属性中。

5. 解析子元素replaced-method

> - 方法替换：可以在运行时用新的方法替换现有的方法。
> - 与look-up不同的是，replaced-method不但可以动态地替换返回实体bean，而且还能动态地更改原有方法的逻辑。
>
> ```Java
> package test.replacedmethod.bean;
>
> public class TestChangeMethod {
>
>     public void changeMe() {
>         System.out.println("changeMe");
>     }
> }
>
> public class TestMethodReplacer implements MethodReplacer {
>
>     @Override
>     public Object reimplement(Object obj, Method method, Object[] args) throws Throwable {
>         System.out.println("我替换了原有的方法");
>         return null;
>     }
> }
>
> package test.replacedmethod.bean;
>
> public class Main {
>
> public static void main(String[] args) {
>         ApplicationContext bf = new ClassPathXmlApplicationContext("test/replacedmethod/replacedmethodTest.xml");
>         TestChangeMethod test = (TestChangeMethod) bf.getBean("testChangeMethod");
>         test.changeMe();
>     }
> }
> ```
>
> ```XML
> <?xml version="1.0" encoding="UTF-8"?>
> <beans xmlns="http://www.springframework.org/schema/beans"
>        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
>        xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
>
>     <bean id="testChangeMethod" class="test.replacedmethod.bean.TestChangeMethod">
>         <replaced-method name="changeMe" replacer="replacer"/>
>     </bean>
>
>     <bean id="replacer" class="test.replacedmethod.bean.TestMethodReplacer"/>
>
> </beans>
> ```
>
> ```控制台
> 我替换了原有的方法
> ```
>
> - 元素提取过程：
>
> ```Java
> 	//BeanDefinitionParserDelegate
> 	public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {
> 		NodeList nl = beanEle.getChildNodes();
> 		for (int i = 0; i < nl.getLength(); i++) {
> 			Node node = nl.item(i);
> 			//仅当在Spring默认bean的子元素下且为replaced-method时有效
> 			if (isCandidateElement(node) && nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {
> 				Element replacedMethodEle = (Element) node;
> 				//提取要替换就的方法
> 				String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);
>               
> 				//提取对应的新的替换方法
> 				String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);
> 				ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);
> 				// Look for arg-type match elements.
> 				List<Element> argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);
> 				for (Element argTypeEle : argTypeEles) {
> 					//记录参数
> 					String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);
> 					match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));
> 					if (StringUtils.hasText(match)) {
> 						replaceOverride.addTypeIdentifier(match);
> 					}
> 				}
> 				replaceOverride.setSource(extractSource(replacedMethodEle));
> 				overrides.addOverride(replaceOverride);
> 			}
> 		}
> 	}
> ```
>
> - 无论是look-up还是replaced-method都是构造了一个MethodOverride，并最终记录在了AbstractBeanDefinition中的methodOverrides属性中。

6. 解析子元素constructor-arg

> - 使用例子：
> ```XML
> <beans>
>   <!-- 默认的情况下是按照参数的顺序注入，当指定index索引后就可以改变注入参数的顺序 -->
>   <bean id="helloBean" class="com.HelloBean">
>       <constructor-arg index="0">
>           <value>老王</value>
>       </constructor-arg>
>       <constructor-arg index="1">
>           <value>你好</value>
>       </constructor-arg>
>   </bean>
> </beans>
> ```
>
> - 对于constructor-arg子元素的解析，Spring是通过`parseConstructorArgElements(Element beanEle, BeanDefinition bd)`函数来实现的。
>
> ```Java
> 	public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {
> 		NodeList nl = beanEle.getChildNodes();
> 		for (int i = 0; i < nl.getLength(); i++) {
> 			Node node = nl.item(i);
> 			if (isCandidateElement(node) && nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {
> 				//解析constructor-arg
> 				parseConstructorArgElement((Element) node, bd);
> 			}
> 		}
> 	}
> ```
>
> - 遍历所有子元素，提取所有constructor-arg，然后通过`parseConstructorArgElement((Element) node, bd)`进行解析。
>
> ```Java
> 	public void parseConstructorArgElement(Element ele, BeanDefinition bd) {
> 		//提取index属性
> 		String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);
> 		//提取type属性
> 		String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);
> 		//提取name属性
> 		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
> 		if (StringUtils.hasLength(indexAttr)) {
> 			try {
> 				int index = Integer.parseInt(indexAttr);
> 				if (index < 0) {
> 					error("'index' cannot be lower than 0", ele);
> 				}
> 				else {
> 					try {
> 						this.parseState.push(new ConstructorArgumentEntry(index));
> 						//解析ele对应的属性元素
> 						Object value = parsePropertyValue(ele, bd, null);
> 						ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
> 						if (StringUtils.hasLength(typeAttr)) {
> 							valueHolder.setType(typeAttr);
> 						}
> 						if (StringUtils.hasLength(nameAttr)) {
> 							valueHolder.setName(nameAttr);
> 						}
> 						valueHolder.setSource(extractSource(ele));
> 						//不允许重复指定相同的参数
> 						if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {
> 							error("Ambiguous constructor-arg entries for index " + index, ele);
> 						}
> 						else {
> 							bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);
> 						}
> 					}
> 					finally {
> 						this.parseState.pop();
> 					}
> 				}
> 			}
> 			catch (NumberFormatException ex) {
> 				error("Attribute 'index' of tag 'constructor-arg' must be an integer", ele);
> 			}
> 		}
> 		else {
> 			//没有index属性则忽略去属性，自动寻找
> 			try {
> 				this.parseState.push(new ConstructorArgumentEntry());
> 				Object value = parsePropertyValue(ele, bd, null);
> 				ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
> 				if (StringUtils.hasLength(typeAttr)) {
> 					valueHolder.setType(typeAttr);
> 				}
> 				if (StringUtils.hasLength(nameAttr)) {
> 					valueHolder.setName(nameAttr);
> 				}
> 				valueHolder.setSource(extractSource(ele));
> 				bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);
> 			}
> 			finally {
> 				this.parseState.pop();
> 			}
> 		}
> 	}
> ```
>
> - 上面一段代码首先是提取constructor-arg上必要的属性（index、type、name）。
> - 如果配置中指定了index属性，那么操作步骤如下：
>
> > 1. 解析constructor-arg元素。
> > 2. 使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素。
> > 3. 将type、name和index属性一并封装在ConstructorArgumentValues.ValueHolder类型中并添加至当前BeanDefinition的constructorArgumentValues的indexdArgumentValues属性中。
>
> - 如果没有指定index属性，那么操作步骤如下：
>
> > 1. 解析constructor-arg元素。
> > 2. 使用ConstructorArgumentValues.ValueHolder类型来封装解析出来的元素。
> > 3. 将type、name和index属性一并封装在ConstructorArgumentValues.ValueHolder类型中并添加至当前BeanDefinition的constructorArgumentValues的genericArgumentValues属性中。
>
> - 对于是否指定index属性来讲，Spring的处理流程是不同的，关键在于属性信息被保存的位置。
> - 进一步了解解析构造函数配置中子元素的过程，进入`parsePropertyValue(ele, bd, null)`函数。
>
> ```Java
> 	public Object parsePropertyValue(Element ele, BeanDefinition bd, String propertyName) {
> 		String elementName = (propertyName != null) ?
> 						"<property> element for property '" + propertyName + "'" :
> 						"<constructor-arg> element";
>
> 		// Should only have one child element: ref, value, list, etc.
> 		//一个属性只能对应一种类型：ref、value、list等
> 		NodeList nl = ele.getChildNodes();
> 		Element subElement = null;
> 		for (int i = 0; i < nl.getLength(); i++) {
> 			Node node = nl.item(i);
> 			//对应description或者meta不处理
> 			if (node instanceof Element && !nodeNameEquals(node, DESCRIPTION_ELEMENT) &&
> 					!nodeNameEquals(node, META_ELEMENT)) {
> 				// Child element is what we're looking for.
> 				if (subElement != null) {
> 					error(elementName + " must not contain more than one sub-element", ele);
> 				}
> 				else {
> 					subElement = (Element) node;
> 				}
> 			}
> 		}
> 		//解析constructor-arg上的ref属性
> 		boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
> 		//解析constructor-arg上的value属性
> 		boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);
> 		if ((hasRefAttribute && hasValueAttribute) ||
> 				((hasRefAttribute || hasValueAttribute) && subElement != null)) {
> 			/**
> 			 * 在constructor-arg上不存在：
> 			 * 1、同时既有ref属性又有value属性
> 			 * 2、存在ref属性或者value属性且又有子元素
> 			 */
> 			error(elementName +
> 					" is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element", ele);
> 		}
>
> 		if (hasRefAttribute) {
> 			//ref属性的处理，使用RuntimeBeanReference封装对应的ref名称
> 			String refName = ele.getAttribute(REF_ATTRIBUTE);
> 			if (!StringUtils.hasText(refName)) {
> 				error(elementName + " contains empty 'ref' attribute", ele);
> 			}
> 			RuntimeBeanReference ref = new RuntimeBeanReference(refName);
> 			ref.setSource(extractSource(ele));
> 			return ref;
> 		}
> 		else if (hasValueAttribute) {
> 			//value属性的处理，使用TypedStringValue封装
> 			TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
> 			valueHolder.setSource(extractSource(ele));
> 			return valueHolder;
> 		}
> 		else if (subElement != null) {
> 			//解析子元素
> 			return parsePropertySubElement(subElement, bd);
> 		}
> 		else {
> 			// Neither child element nor "ref" or "value" attribute found.
> 			//既没有ref也没有value也没有子元素
> 			error(elementName + " must specify a ref or value", ele);
> 			return null;
> 		}
> 	}
> ```
>
> - 对构造函数中属性元素的解析过程：
> >
> >    1. 略过description或者meta。
> >
> >    2. 提取constructor-arg上的ref和value属性，以便于根据规则验证正确性，其规则为constructor-arg上不存在以下情况。
> >
> > - 同时既有ref属性又用value属性。
> > - 存在ref属性或者value属性又有子元素。
> >
> >    3. ref属性的处理。
> >
> > 使用RuntimeBeanReference封装对应的ref名称，如：`<constructor-arg ref="a">`
> >
> >    4. value属性的处理。
> >
> > 使用TypedStringValue封装，例如：`<constructor-arg value="a">`
> >
> >    5. 子元素的处理。
> >
> > 例如：
> >
> > ```XML
> > <constructor-arg>
> > 	<map>
> > 		<entry key="key" value="value"/>
> >   	</map>
> > </constructor-arg>
> > ```
>
> - 对于子元素的处理，使用`parsePropertySubElement(subElement, bd)`方法实现了对各种子元素的分类处理。
>
> ```Java
> 	//BeanDefinitionParserDelegate
> 	public Object parsePropertySubElement(Element ele, BeanDefinition bd) {
> 		return parsePropertySubElement(ele, bd, null);
> 	}
>
> 	public Object parsePropertySubElement(Element ele, BeanDefinition bd, String defaultValueType) {
> 		if (!isDefaultNamespace(ele)) {
> 			return parseNestedCustomElement(ele, bd);
> 		}
> 		else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
> 			BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
> 			if (nestedBd != null) {
> 				nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
> 			}
> 			return nestedBd;
> 		}
> 		else if (nodeNameEquals(ele, REF_ELEMENT)) {
> 			// A generic reference to any name of any bean.
> 			String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
> 			boolean toParent = false;
> 			if (!StringUtils.hasLength(refName)) {
> 				// A reference to the id of another bean in the same XML file.
> 				//解析local
> 				refName = ele.getAttribute(LOCAL_REF_ATTRIBUTE);
> 				if (!StringUtils.hasLength(refName)) {
> 					// A reference to the id of another bean in a parent context.
> 					//解析parent
> 					refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
> 					toParent = true;
> 					if (!StringUtils.hasLength(refName)) {
> 						error("'bean', 'local' or 'parent' is required for <ref> element", ele);
> 						return null;
> 					}
> 				}
> 			}
> 			if (!StringUtils.hasText(refName)) {
> 				error("<ref> element contains empty target attribute", ele);
> 				return null;
> 			}
> 			RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
> 			ref.setSource(extractSource(ele));
> 			return ref;
> 		}
> 		//对idref元素的解析
> 		else if (nodeNameEquals(ele, IDREF_ELEMENT)) {
> 			return parseIdRefElement(ele);
> 		}
> 		//对value子元素的解析
> 		else if (nodeNameEquals(ele, VALUE_ELEMENT)) {
> 			return parseValueElement(ele, defaultValueType);
> 		}
> 		//对null子元素的解析
> 		else if (nodeNameEquals(ele, NULL_ELEMENT)) {
> 			// It's a distinguished null value. Let's wrap it in a TypedStringValue
> 			// object in order to preserve the source location.
> 			TypedStringValue nullHolder = new TypedStringValue(null);
> 			nullHolder.setSource(extractSource(ele));
> 			return nullHolder;
> 		}
> 		else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {
> 			//解析array子元素
> 			return parseArrayElement(ele, bd);
> 		}
> 		else if (nodeNameEquals(ele, LIST_ELEMENT)) {
> 			//解析list子元素
> 			return parseListElement(ele, bd);
> 		}
> 		else if (nodeNameEquals(ele, SET_ELEMENT)) {
> 			//解析set子元素
> 			return parseSetElement(ele, bd);
> 		}
> 		else if (nodeNameEquals(ele, MAP_ELEMENT)) {
> 			//解析map子元素
> 			return parseMapElement(ele, bd);
> 		}
> 		else if (nodeNameEquals(ele, PROPS_ELEMENT)) {
> 			//解析props子元素
> 			return parsePropsElement(ele);
> 		}
> 		else {
> 			error("Unknown property sub-element: [" + ele.getNodeName() + "]", ele);
> 			return null;
> 		}
> 	}
> ```

7. 解析子元素property

> `parsePropertyElements(ele, bd)`函数完成了对property属性的提取，property使用方法如下：
>
> ```XML
> <bean id="test" class="test.TestClass">
> 	<property name="testStr" value="aaa"/>
> </bean>
>
> <!-- 或者 -->
> <bean id="a">
> 	<property name="p">
> 		<list>
> 			<value>aa</value>
> 			<value>bb</value>
> 		</list>
>     </property>
> </bean>
> ```
>
> - 具体的解析过程如下：
>
> ```Java
> 	public void parsePropertyElements(Element beanEle, BeanDefinition bd) {
> 		NodeList nl = beanEle.getChildNodes();
> 		for (int i = 0; i < nl.getLength(); i++) {
> 			Node node = nl.item(i);
> 			if (isCandidateElement(node) && nodeNameEquals(node, PROPERTY_ELEMENT)) {
> 				parsePropertyElement((Element) node, bd);
> 			}
> 		}
> 	}
> ```
>
> - 提取所有property的子元素，然后调用`parsePropertyElement((Element) node, bd)`处理。
>
> ```Java
> 	public void parsePropertyElement(Element ele, BeanDefinition bd) {
> 		//获取配置元素中的name的值
> 		String propertyName = ele.getAttribute(NAME_ATTRIBUTE);
> 		if (!StringUtils.hasLength(propertyName)) {
> 			error("Tag 'property' must have a 'name' attribute", ele);
> 			return;
> 		}
> 		this.parseState.push(new PropertyEntry(propertyName));
> 		try {
> 			//不允许多次对同一属性配置
> 			if (bd.getPropertyValues().contains(propertyName)) {
> 				error("Multiple 'property' definitions for property '" + propertyName + "'", ele);
> 				return;
> 			}
> 			Object val = parsePropertyValue(ele, bd, propertyName);
> 			PropertyValue pv = new PropertyValue(propertyName, val);
> 			parseMetaElements(ele, pv);
> 			pv.setSource(extractSource(ele));
> 			bd.getPropertyValues().addPropertyValue(pv);
> 		}
> 		finally {
> 			this.parseState.pop();
> 		}
> 	}
> ```
>
> 8. 解析子元素qualifier
>
> - 在使用Spring框架中进行自动注入时，Spring容器中匹配的候选Bean数目必须有且仅有一个。
> - Spring允许我们通过Qualifier指定注入Bean的名称。
>
> ```XML
> <bean id="myTestBean" class="bean.MyTestBean">
> 	<qualifier type="org.springframework.beans.factory.annotation.Qualifier" value="qf"/>
> </bean>
> ```

### AbstractBeanDefinition属性

- 以上便完成了对XML文档到GenericBeanDefinition的转换。
- GenericBeanDefinition只是子类的实现，大部分的通用属性都保存在了AbstractBeanDefinition中。

```Java
//AbstractBeanDefinition
public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor
		implements BeanDefinition, Cloneable {

	//此处省略静态变量以及final常量
  
	private volatile Object beanClass;

  	/**
     * bean的作用范围，对应bean属性scope
     */
	private String scope = SCOPE_DEFAULT;
  
  	/**
     * 是否抽象，来自bean属性scope
     */
	private boolean abstractFlag = false;
  
  	/**
     * 是否是延迟加载，来自属性scope
     */
	private boolean lazyInit = false;
  
  	/**
     * 自动注入模式，对应bean属性autowire
     */
	private int autowireMode = AUTOWIRE_NO;
  
  	/**
     * 依赖检查，Spring3.0后弃用
     */
	private int dependencyCheck = DEPENDENCY_CHECK_NONE;
  
  	/**
     * 用来表示一个bean的实例化依靠另一个bean先实例化，对应bean属性depend-on
     */
	private String[] dependsOn;
  
  	/**
     * autowire-candidate属性设置为false，这样容器在查找自动装配对象时，
     * 将不考虑该bean，即它不会被考虑作为其他bean自动装配的候选者，
     * 但是该bean本身还是可以使用自动装配来注入其他bean的。
     */
	private boolean autowireCandidate = true;
  
  	/**
     * 自动装配时当出现多个bean候选者，将作为首选者，对应bean属性primary
     */
	private boolean primary = false;
  
  	/**
     * 用于记录Qualifier，对应子元素qualifier
     */
	private final Map<String, AutowireCandidateQualifier> qualifiers =
			new LinkedHashMap<String, AutowireCandidateQualifier>(0);

  	/**
     * 允许访问非公开的构造器和方法，程序设置
     */
	private boolean nonPublicAccessAllowed = true;
  
  	/**
     * 是否以一种宽松的模式解析构造函数，默认为true，
     * 如果为false，则在如下情况
     * interface ITest{}
     * class ITestImpl implements ITest{};
     * class Main{
     *   Main(ITest i) {}
     *   Main(ITestImpl i) {}
     * }
     * 抛出异常，因为Spring无法准确定位哪个构造函数
     * 程序设置
     */
	private boolean lenientConstructorResolution = true;
  
  	/**
     * 对应bean属性factory-bean，用法：
     * <bean id="instanceFactoryBean" class="example.chapter3.InstanceFactoryBean"/>
     * <bean id="currentTime" factory-bean="instanceFactoryBean" factory-method="createTime"/>
     */
	private String factoryBeanName;
  
  	/**
     * 对应bean属性factory-method
     */
	private String factoryMethodName;
  
  	/**
     * 记录构造函数注入属性，对应bean属性constructor-arg
     */
	private ConstructorArgumentValues constructorArgumentValues;
  
  	/**
     * 普通属性集合
     */
	private MutablePropertyValues propertyValues;
  
  	/**
     * 方法重写的持有者，记录look-method、replaced-method元素
     */
	private MethodOverrides methodOverrides = new MethodOverrides();
  
  	/**
     * 初始化方法，对应bean属性init-method
     */
	private String initMethodName;
  
  	/**
     * 销毁方法，对应bean属性destroy-method
     */
	private String destroyMethodName;
  
  	/**
     * 是否执行init-method，程序设置
     */
	private boolean enforceInitMethod = true;
  
  	/**
     * 是否执行destroy-method，程序设置
     */
	private boolean enforceDestroyMethod = true;
  
  	/**
     * 是否是用户定义的而不是应用程序本身定义的，创建AOP时候为true，程序设置
     */
	private boolean synthetic = false;
  
  	/**
     * 定义这个bean的应用，APPLICATION：用户，INFRASTRUCTURE：完全内部使用，与用户无关，SUPPORT：某些复杂配置的一部分
     * 程序设置
     */
	private int role = BeanDefinition.ROLE_APPLICATION;
  
  	/**
     * bean的描述信息
     */
	private String description;
  
  	/**
     * 这个bean定义的资源
     */
	private Resource resource;
  
  	//此处省略get/set方法
}
```

### 解析默认标签中的自定义标签元素

- 默认标签解析函数的起始函数：

```Java
	//DefaultBeanDefinitionDocumentReader
	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				// Register the final decorated instance.
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error("Failed to register bean definition with name '" +
						bdHolder.getBeanName() + "'", ele, ex);
			}
			// Send registration event.
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
```

- `bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);`对beanDefintion进行装饰。
- 适用场景：

```XML
<bean id="test" class="test.MyClass">
	<mybean:user username="aaa"/>
</bean>
```

- 当Spring中的bean适用的是默认的标签配置，但是其中的子元素却适用了自定义的配置时，这句代码便会起作用了。

```Java
	//BeanDefinitionParserDelegate
	public BeanDefinitionHolder decorateBeanDefinitionIfRequired(Element ele, BeanDefinitionHolder definitionHolder) {
		return decorateBeanDefinitionIfRequired(ele, definitionHolder, null);
	}
```

- 第三参数的作用是使用父类的scope属性。
- 这里分析的是顶层配置，所以传递null。

```Java
	//BeanDefinitionParserDelegate
	public BeanDefinitionHolder decorateBeanDefinitionIfRequired(
			Element ele, BeanDefinitionHolder definitionHolder, BeanDefinition containingBd) {

		BeanDefinitionHolder finalDefinition = definitionHolder;

		// Decorate based on custom attributes first.
		NamedNodeMap attributes = ele.getAttributes();
		//遍历所有的属性，看看是否有适用于修饰的属性
		for (int i = 0; i < attributes.getLength(); i++) {
			Node node = attributes.item(i);
			finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
		}

		// Decorate based on custom nested elements.
		NodeList children = ele.getChildNodes();
		//遍历所有的子节点，看看是否有适用于修饰的子元素
		for (int i = 0; i < children.getLength(); i++) {
			Node node = children.item(i);
			if (node.getNodeType() == Node.ELEMENT_NODE) {
				finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
			}
		}
		return finalDefinition;
	}
```

- 上面的代码分别对元素的所有属性以及子节点进行了decorateIfRequired函数的调用。

```Java
	//BeanDefinitionParserDelegate
	public BeanDefinitionHolder decorateIfRequired(
			Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd) {

		//获取自定义标签的命名空间
		String namespaceUri = getNamespaceURI(node);
		//对于非默认标签进行修饰
		if (!isDefaultNamespace(namespaceUri)) {
			//根据命名空间找到对应的处理器
			NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
			if (handler != null) {
				//进行修饰
				return handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));
			}
			else if (namespaceUri != null && namespaceUri.startsWith("http://www.springframework.org/")) {
				error("Unable to locate Spring NamespaceHandler for XML schema namespace [" + namespaceUri + "]", node);
			}
			else {
				// A custom namespace, not to be handled by Spring - maybe "xml:...".
				if (logger.isDebugEnabled()) {
					logger.debug("No Spring NamespaceHandler found for XML schema namespace [" + namespaceUri + "]");
				}
			}
		}
		return originalDef;
	}
```

- 程序的调理：首先获取属性或者元素的命名空间，以此来判断该元素或者属性是否适用于自定义标签的解析条件，找出自定义类型所对应的NamespaceHandler并进一步解析。
- 在decorateBeanDefinitionIfRequired中我们可以看到对于程序默认的标签的处理其实是直接略过的，因为默认的标签到这里已经被处理完了。
- 在方法中实现了寻找自定义标签并根据自定义标签寻找命名空间处理器。

### 注册解析的BeanDefinition

- 注册DefaultBeanDefinitionDocumentReader类中`processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate)`调用`BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());`方法。

```Java
	//BeanDefinitionReaderUtils
	public static void registerBeanDefinition(
			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
			throws BeanDefinitionStoreException {

		// Register bean definition under primary name.
		//使用beanName做唯一表示注册
		String beanName = definitionHolder.getBeanName();
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

		// Register aliases for bean name, if any.
		//注册所有的别名
		String[] aliases = definitionHolder.getAliases();
		if (aliases != null) {
			for (String alias : aliases) {
				registry.registerAlias(beanName, alias);
			}
		}
	}
```

- 解析的BeanDefinition都会被注册到BeanDefinitionRegistry类型的实例registry中，而对于beanDefinition的注册分成两部分：**通过beanName的注册以及通过别名的注册**。

##### 1. 通过beanName注册BeanDefinition

- 对于beanDefinition的注册，`registerBeanDefinition(beanName, definitionHolder.getBeanDefinition())`除了将beanDefinition直接放入map中，使用beanName作为key外，Spring还做了点别的事情。

```Java
	//DefaultListableBeanFactory
	@Override
	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException {

		Assert.hasText(beanName, "Bean name must not be empty");
		Assert.notNull(beanDefinition, "BeanDefinition must not be null");

		if (beanDefinition instanceof AbstractBeanDefinition) {
			try {
				/**
				 * 注册的最后一次校验，这里的校验不同于之前的XML文件校验。
				 * 主要是对于AbstractBeanDefinition属性中的methodOverrides校验。
				 * 校验methodOverrides是否与工厂方法并存或者methodOverrides对应的方法根本不存在
				 */
				((AbstractBeanDefinition) beanDefinition).validate();
			}
			catch (BeanDefinitionValidationException ex) {
				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						"Validation of bean definition failed", ex);
			}
		}

		BeanDefinition oldBeanDefinition;

		//因为beanDefinitionMap是全局变量，这里定会存在并发访问的情况
		//旧版使用synchronized保证，这里我猜是使用ConcurrentHashMap保证
		oldBeanDefinition = this.beanDefinitionMap.get(beanName);
		if (oldBeanDefinition != null) {
			//如果对应BeanName已经注册且在陪值中配置了bean不允许被覆盖，则抛出异常
			if (!isAllowBeanDefinitionOverriding()) {
				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						"Cannot register bean definition [" + beanDefinition + "] for bean '" + beanName +
						"': There is already [" + oldBeanDefinition + "] bound.");
			}
			else if (oldBeanDefinition.getRole() < beanDefinition.getRole()) {
				// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
				if (this.logger.isWarnEnabled()) {
					this.logger.warn("Overriding user-defined bean definition for bean '" + beanName +
							"' with a framework-generated bean definition: replacing [" +
							oldBeanDefinition + "] with [" + beanDefinition + "]");
				}
			}
			else if (!beanDefinition.equals(oldBeanDefinition)) {
				if (this.logger.isInfoEnabled()) {
					this.logger.info("Overriding bean definition for bean '" + beanName +
							"' with a different definition: replacing [" + oldBeanDefinition +
							"] with [" + beanDefinition + "]");
				}
			}
			else {
				if (this.logger.isDebugEnabled()) {
					this.logger.debug("Overriding bean definition for bean '" + beanName +
							"' with an equivalent definition: replacing [" + oldBeanDefinition +
							"] with [" + beanDefinition + "]");
				}
			}
			//注册BeanDefinition
			this.beanDefinitionMap.put(beanName, beanDefinition);
		}
		else {
			if (hasBeanCreationStarted()) {
				// Cannot modify startup-time collection elements anymore (for stable iteration)
				synchronized (this.beanDefinitionMap) {
					this.beanDefinitionMap.put(beanName, beanDefinition);
					List<String> updatedDefinitions = new ArrayList<String>(this.beanDefinitionNames.size() + 1);
					updatedDefinitions.addAll(this.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					this.beanDefinitionNames = updatedDefinitions;
					if (this.manualSingletonNames.contains(beanName)) {
						Set<String> updatedSingletons = new LinkedHashSet<String>(this.manualSingletonNames);
						updatedSingletons.remove(beanName);
						this.manualSingletonNames = updatedSingletons;
					}
				}
			}
			else {
				// Still in startup registration phase
				//注册BeanDefinition
				this.beanDefinitionMap.put(beanName, beanDefinition);
				//记录beanName
				this.beanDefinitionNames.add(beanName);
				this.manualSingletonNames.remove(beanName);
			}
			this.frozenBeanDefinitionNames = null;
		}

		if (oldBeanDefinition != null || containsSingleton(beanName)) {
			//重置所有beanName对应的缓存
			resetBeanDefinition(beanName);
		}
	}
```

- 上面的代码在对于bean的注册处理方式上，主要进行了几个步骤。

> 1. 对AbstractBeanDefinition的校验。在解析XML文件的时候我们提过校验，是针对于对XML格式的校验，而此时的校验是对于AbstractBeanDefinition的methodOverrides属性的。
> 2. 对beanName已经注册的情况的处理。如果设置了不允许bean的覆盖，则需要抛出异常，否则直接覆盖。
> 3. 加入map缓存。
> 4. 清除解析之前留下的对应的beanName的缓存。

##### 通过别名注册BeanDefinition

- BeanDefinitionReaderUtils在`registerBeanDefinition(BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)`中通过`registerAlias(beanName, alias)`方法注册别名。

```Java
	//SimpleAliasRegistry
	@Override
	public void registerAlias(String name, String alias) {
		Assert.hasText(name, "'name' must not be empty");
		Assert.hasText(alias, "'alias' must not be empty");
		//如果beanName与alias相同的话不记录alias，并删除对应的alias
		if (alias.equals(name)) {
			this.aliasMap.remove(alias);
		}
		else {
			String registeredName = this.aliasMap.get(alias);
			//现有的别名，不需要重复注册
			if (registeredName != null) {
				if (registeredName.equals(name)) {
					// An existing alias - no need to re-register
					return;
				}
				//如果alias不允许被覆盖则抛出异常
				if (!allowAliasOverriding()) {
					throw new IllegalStateException("Cannot register alias '" + alias + "' for name '" +
							name + "': It is already registered for name '" + registeredName + "'.");
				}
			}
			//当A->B存在时，若再次出现A->C->B时候则会抛出异常
			checkForAliasCircle(name, alias);
			this.aliasMap.put(alias, name);
		}
	}
```

- 注册alias的步骤：

> 1. 若alias与beanName并名称相同则不需要处理并删除掉原有的alias。
> 2. alias覆盖处理，若aliasName已经使用并已经指向另一beanName则需要用户的设置进行处理。
> 3. alias循环检查，当A->B存在时，若再次出现A->C->B时候则会抛出异常。
> 4. 注册alias。

### 通知监听器解析及注册完成

- DefaultBeanDefinitionDocumentReader通过`getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder))`完成此工作。
- 这里实现只为扩展，当程序开发人员需要对注册BeanDefinition时间进行监听时可以通过注册监听器的方式并将处理逻辑写入监听器，目前在Spring中并没有对此事件做任何逻辑处理。

